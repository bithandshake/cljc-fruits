
# loop.api isomorphic namespace

##### [README](../../../README.md) > [DOCUMENTATION](../../COVER.md) > loop.api

### Index

- [do-while](#do-while)

- [reduce-indexed](#reduce-indexed)

- [reduce-kv-indexed](#reduce-kv-indexed)

- [some-indexed](#some-indexed)

### do-while

```
@param (function) f
@param (*) n
Az f függvény első paramétere
@param (function) test-f
A teszt-függvény, aminek ha igaz a kimenete, akkor a ciklus megáll
```

```
@example
(do-while (fn [{:keys [my-numbers x] :as n}]
              (if (vector/contains-item? my-numbers x)
                  (assoc  n :x (inc x))
                  (update n :my-numbers vector/conj-item x)))
          {:my-numbers [0 1 2 4]
           :x 0}
          (fn [%] (= (count (:my-numbers %1)) 5)))
=>
{:my-numbers [0 1 2 4 3] :x 3}
```

```
@example
(do-while #(inc %)
           0
          #(> % 3))
=>
4
```

```
@return (*)
```

<details>
<summary>Source code</summary>

```
(defn do-while
  [f n test-f]
  (let [result (f n)]
       (if (test-f     result)
           (return     result)
           (do-while f result test-f))))
```

</details>

<details>
<summary>Require</summary>

```
(ns my-namespace (:require [loop.api :refer [do-while]]))

(loop.api/do-while ...)
(do-while          ...)
```

</details>

---

### reduce-indexed

```
@param (function) f
@param (*) initial
@param (collection) coll
```

```
@usage
(reduce-indexed (fn [o dex x]) nil [:a :b])
```

```
@return (*)
```

<details>
<summary>Source code</summary>

```
(defn reduce-indexed
  [f initial coll]
  (letfn [(fi [[o dex] x]
              [(f o dex x)
               (inc dex)])]
         (first (reduce fi [initial 0] coll))))
```

</details>

<details>
<summary>Require</summary>

```
(ns my-namespace (:require [loop.api :refer [reduce-indexed]]))

(loop.api/reduce-indexed ...)
(reduce-indexed          ...)
```

</details>

---

### reduce-kv-indexed

```
@param (function) f
@param (*) initial
@param (map) map
```

```
@usage
(reduce-kv-indexed (fn [o dex k v]) nil {})
```

```
@return (*)
```

<details>
<summary>Source code</summary>

```
(defn reduce-kv-indexed
  [f initial map]
  (letfn [(fi [[o dex] k v]
              [(f o dex k v)
               (inc dex)])]
         (first (reduce-kv fi [initial 0] map))))
```

</details>

<details>
<summary>Require</summary>

```
(ns my-namespace (:require [loop.api :refer [reduce-kv-indexed]]))

(loop.api/reduce-kv-indexed ...)
(reduce-kv-indexed          ...)
```

</details>

---

### some-indexed

```
@param (function) test-f
@param (collection) coll
```

```
@usage
(some-indexed (fn [dex x]) [...])
```

```
@example
(some-indexed #(if (= 3    %1)
                   (return %2))
               [:a :b :c :d :e])
=>
:d
```

```
@example
(some-indexed #(if (= :d   %2)
                   (return %1))
               [:a :b :c :d :e])
=>
3
```

```
@return (*)
```

<details>
<summary>Source code</summary>

```
(defn some-indexed
  [test-f coll]
  (letfn [(fi [test-f coll dex]
              (if-let [result (test-f dex (get coll dex))]
                      (return result)
                      (when-not (= dex (-> coll count dec))
                                (fi test-f coll (inc dex)))))]
         (fi test-f coll 0)))
```

</details>

<details>
<summary>Require</summary>

```
(ns my-namespace (:require [loop.api :refer [some-indexed]]))

(loop.api/some-indexed ...)
(some-indexed          ...)
```

</details>

---

This documentation is generated by the [docs-api](https://github.com/bithandshake/docs-api) engine

