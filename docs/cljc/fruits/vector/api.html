<!DOCTYPE html>
<html><html><head><style type="text/css">body{margin:0 0 0 560px;padding:60px 48px}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-container{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{font-size:13px;letter-spacing:.5px;line-height:18px;padding:3px 12px;white-space:inherit}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:24px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.text--l{font-size:14px;line-height:18px}.text--semi-bold{font-weight:500}.text--bold{font-weight:600}.color--basic{color:#303030}.color--primary{color:#0088cc}.color--secondary{color:#8800cc}.color--muted{color:#606060}.color--warning{color:#cc00aa}.collapsible-wrapper{display:flex;flex-direction:column}.collapsible-button{cursor:pointer;position:relative;user-select:none;width:fit-content}.collapsible-button:hover{color:#888}.collapsible-button::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;position:absolute;height:24px;right:-24px;top:0;width:24px}.collapsible-wrapper[data-expanded="true"] .collapsible-button::after{content:'▲'}.collapsible-wrapper .content-block--box{display:none}.collapsible-wrapper[data-expanded="true"] .content-block--box{display:block}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{font-size:12px;line-height:60px;padding:0 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{font-size:18px;line-height:60px;text-transform:uppercase}#top-bar--author-name{font-size:12px}#top-bar--library-version{font-size:12px;line-height:18px;margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{color:#aa55bb;font-size:12px;letter-spacing:.8px;line-height:42px;padding:0 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{font-size:18px;line-height:24px;margin-top:24px}#declarations{display:flex;flex-direction:column}.declaration--wrapper{padding-top:96px}.declaration--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.tutorial--wrapper{padding-top:96px}.tutorial--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.content-blocks{display:flex;flex-direction:column}.content-block--separator{height:12px}.content-block--label{display:flex;gap:4px;line-height:24px}.content-block--box{background-color:#fafafa;color:#333;line-height:16px;margin:0;padding:12px 8px}.content-block--preview-image{border:1px solid #dedede;display:block;max-height:480px;max-width:640px;min-height:48px;min-width:64px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.expanded==='true'){collapsible.dataset.expanded='false';}else{collapsible.dataset.expanded='true';}}</script></head><body><div id="primary-list"><div class="scroll-container"><div class="primary-list--container"><pre class="text--xs color--muted">Isomorphic namespaces</pre><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/alphabet/api.html"><pre class="button color--primary ">fruits.alphabet.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/atom/api.html"><pre class="button color--primary ">fruits.atom.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/audit/api.html"><pre class="button color--primary ">fruits.audit.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/base64/api.html"><pre class="button color--primary ">fruits.base64.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/bson/api.html"><pre class="button color--primary ">fruits.bson.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/css/api.html"><pre class="button color--primary ">fruits.css.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/eql/api.html"><pre class="button color--primary ">fruits.eql.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/format/api.html"><pre class="button color--primary ">fruits.format.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/gestures/api.html"><pre class="button color--primary ">fruits.gestures.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/hiccup/api.html"><pre class="button color--primary ">fruits.hiccup.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/href/api.html"><pre class="button color--primary ">fruits.href.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/html/api.html"><pre class="button color--primary ">fruits.html.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/http/api.html"><pre class="button color--primary ">fruits.http.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/integer/api.html"><pre class="button color--primary ">fruits.integer.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/json/api.html"><pre class="button color--primary ">fruits.json.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/keyword/api.html"><pre class="button color--primary ">fruits.keyword.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/layout/api.html"><pre class="button color--primary ">fruits.layout.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/logic/api.html"><pre class="button color--primary ">fruits.logic.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/loop/api.html"><pre class="button color--primary ">fruits.loop.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/lorem-ipsum/api.html"><pre class="button color--primary ">fruits.lorem-ipsum.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/map/api.html"><pre class="button color--primary ">fruits.map.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/math/api.html"><pre class="button color--primary ">fruits.math.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/mixed/api.html"><pre class="button color--primary ">fruits.mixed.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/namespace/api.html"><pre class="button color--primary ">fruits.namespace.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/noop/api.html"><pre class="button color--primary ">fruits.noop.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/normalize/api.html"><pre class="button color--primary ">fruits.normalize.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/pretty/api.html"><pre class="button color--primary ">fruits.pretty.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/print/api.html"><pre class="button color--primary ">fruits.print.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/random/api.html"><pre class="button color--primary ">fruits.random.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/reader/api.html"><pre class="button color--primary ">fruits.reader.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/regex/api.html"><pre class="button color--primary ">fruits.regex.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/seqable/api.html"><pre class="button color--primary ">fruits.seqable.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/string/api.html"><pre class="button color--primary ">fruits.string.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/svg/api.html"><pre class="button color--primary ">fruits.svg.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/syntax/api.html"><pre class="button color--primary ">fruits.syntax.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/uri/api.html"><pre class="button color--primary ">fruits.uri.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/vector/api.html"><pre class="button color--primary button--active">fruits.vector.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-container"><div class="secondary-list--container"><pre class="text--xs color--muted">Declarations</pre><a href="#-__items"><pre class="button color--primary">->>items</pre></a><a href="#-__items-by"><pre class="button color--primary">->>items-by</pre></a><a href="#-_items"><pre class="button color--primary">->items</pre></a><a href="#-_items-by"><pre class="button color--primary">->items-by</pre></a><a href="#abc-items"><pre class="button color--primary">abc-items</pre></a><a href="#after-first-match"><pre class="button color--primary">after-first-match</pre></a><a href="#after-first-occurence"><pre class="button color--primary">after-first-occurence</pre></a><a href="#after-last-match"><pre class="button color--primary">after-last-match</pre></a><a href="#after-last-occurence"><pre class="button color--primary">after-last-occurence</pre></a><a href="#all-items-match_"><pre class="button color--primary">all-items-match?</pre></a><a href="#all-matches"><pre class="button color--primary">all-matches</pre></a><a href="#all-results"><pre class="button color--primary">all-results</pre></a><a href="#any-item-matches_"><pre class="button color--primary">any-item-matches?</pre></a><a href="#before-first-match"><pre class="button color--primary">before-first-match</pre></a><a href="#before-first-occurence"><pre class="button color--primary">before-first-occurence</pre></a><a href="#before-last-match"><pre class="button color--primary">before-last-match</pre></a><a href="#before-last-occurence"><pre class="button color--primary">before-last-occurence</pre></a><a href="#compared-items-sorted_"><pre class="button color--primary">compared-items-sorted?</pre></a><a href="#concat-items"><pre class="button color--primary">concat-items</pre></a><a href="#concat-items-once"><pre class="button color--primary">concat-items-once</pre></a><a href="#conj-item"><pre class="button color--primary">conj-item</pre></a><a href="#conj-item-once"><pre class="button color--primary">conj-item-once</pre></a><a href="#conj-some"><pre class="button color--primary">conj-some</pre></a><a href="#cons-item"><pre class="button color--primary">cons-item</pre></a><a href="#cons-item-once"><pre class="button color--primary">cons-item-once</pre></a><a href="#contains-item_"><pre class="button color--primary">contains-item?</pre></a><a href="#contains-similars_"><pre class="button color--primary">contains-similars?</pre></a><a href="#count-dec_"><pre class="button color--primary">count-dec?</pre></a><a href="#count-inc_"><pre class="button color--primary">count-inc?</pre></a><a href="#count-max_"><pre class="button color--primary">count-max?</pre></a><a href="#count-min_"><pre class="button color--primary">count-min?</pre></a><a href="#count-same_"><pre class="button color--primary">count-same?</pre></a><a href="#count_"><pre class="button color--primary">count?</pre></a><a href="#cut-range"><pre class="button color--primary">cut-range</pre></a><a href="#difference"><pre class="button color--primary">difference</pre></a><a href="#duplicate-first-item"><pre class="button color--primary">duplicate-first-item</pre></a><a href="#duplicate-last-item"><pre class="button color--primary">duplicate-last-item</pre></a><a href="#duplicate-nth-item"><pre class="button color--primary">duplicate-nth-item</pre></a><a href="#duplicate-nth-items"><pre class="button color--primary">duplicate-nth-items</pre></a><a href="#duplicate-second-item"><pre class="button color--primary">duplicate-second-item</pre></a><a href="#empty_"><pre class="button color--primary">empty?</pre></a><a href="#first-dex-by"><pre class="button color--primary">first-dex-by</pre></a><a href="#first-dex-of"><pre class="button color--primary">first-dex-of</pre></a><a href="#first-item"><pre class="button color--primary">first-item</pre></a><a href="#first-match"><pre class="button color--primary">first-match</pre></a><a href="#first-result"><pre class="button color--primary">first-result</pre></a><a href="#flat-items"><pre class="button color--primary">flat-items</pre></a><a href="#from-first-match"><pre class="button color--primary">from-first-match</pre></a><a href="#from-first-occurence"><pre class="button color--primary">from-first-occurence</pre></a><a href="#from-last-match"><pre class="button color--primary">from-last-match</pre></a><a href="#from-last-occurence"><pre class="button color--primary">from-last-occurence</pre></a><a href="#from-subvec"><pre class="button color--primary">from-subvec</pre></a><a href="#gap-items"><pre class="button color--primary">gap-items</pre></a><a href="#insert-item"><pre class="button color--primary">insert-item</pre></a><a href="#item-first_"><pre class="button color--primary">item-first?</pre></a><a href="#item-last_"><pre class="button color--primary">item-last?</pre></a><a href="#item-nth_"><pre class="button color--primary">item-nth?</pre></a><a href="#item-only_"><pre class="button color--primary">item-only?</pre></a><a href="#item-second_"><pre class="button color--primary">item-second?</pre></a><a href="#items-sorted_"><pre class="button color--primary">items-sorted?</pre></a><a href="#keep-first-item"><pre class="button color--primary">keep-first-item</pre></a><a href="#keep-first-items"><pre class="button color--primary">keep-first-items</pre></a><a href="#keep-items"><pre class="button color--primary">keep-items</pre></a><a href="#keep-items-by"><pre class="button color--primary">keep-items-by</pre></a><a href="#keep-last-item"><pre class="button color--primary">keep-last-item</pre></a><a href="#keep-last-items"><pre class="button color--primary">keep-last-items</pre></a><a href="#keep-range"><pre class="button color--primary">keep-range</pre></a><a href="#last-dex-by"><pre class="button color--primary">last-dex-by</pre></a><a href="#last-dex-of"><pre class="button color--primary">last-dex-of</pre></a><a href="#last-item"><pre class="button color--primary">last-item</pre></a><a href="#last-match"><pre class="button color--primary">last-match</pre></a><a href="#last-result"><pre class="button color--primary">last-result</pre></a><a href="#match-count"><pre class="button color--primary">match-count</pre></a><a href="#move-first-item"><pre class="button color--primary">move-first-item</pre></a><a href="#move-item-to-first"><pre class="button color--primary">move-item-to-first</pre></a><a href="#move-item-to-last"><pre class="button color--primary">move-item-to-last</pre></a><a href="#move-item-to-nth"><pre class="button color--primary">move-item-to-nth</pre></a><a href="#move-item-to-second"><pre class="button color--primary">move-item-to-second</pre></a><a href="#move-last-item"><pre class="button color--primary">move-last-item</pre></a><a href="#move-nth-item"><pre class="button color--primary">move-nth-item</pre></a><a href="#move-nth-item-bwd"><pre class="button color--primary">move-nth-item-bwd</pre></a><a href="#move-nth-item-fwd"><pre class="button color--primary">move-nth-item-fwd</pre></a><a href="#move-second-item"><pre class="button color--primary">move-second-item</pre></a><a href="#next-item"><pre class="button color--primary">next-item</pre></a><a href="#no-item-matches_"><pre class="button color--primary">no-item-matches?</pre></a><a href="#not-all-items-match_"><pre class="button color--primary">not-all-items-match?</pre></a><a href="#not-contains-item_"><pre class="button color--primary">not-contains-item?</pre></a><a href="#not-empty_"><pre class="button color--primary">not-empty?</pre></a><a href="#nth-dex-by"><pre class="button color--primary">nth-dex-by</pre></a><a href="#nth-dex-of"><pre class="button color--primary">nth-dex-of</pre></a><a href="#nth-item"><pre class="button color--primary">nth-item</pre></a><a href="#nth-match"><pre class="button color--primary">nth-match</pre></a><a href="#nth-result"><pre class="button color--primary">nth-result</pre></a><a href="#prefix-items"><pre class="button color--primary">prefix-items</pre></a><a href="#prev-item"><pre class="button color--primary">prev-item</pre></a><a href="#remove-duplicates"><pre class="button color--primary">remove-duplicates</pre></a><a href="#remove-first-item"><pre class="button color--primary">remove-first-item</pre></a><a href="#remove-first-items"><pre class="button color--primary">remove-first-items</pre></a><a href="#remove-first-occurence"><pre class="button color--primary">remove-first-occurence</pre></a><a href="#remove-item"><pre class="button color--primary">remove-item</pre></a><a href="#remove-item-once"><pre class="button color--primary">remove-item-once</pre></a><a href="#remove-items"><pre class="button color--primary">remove-items</pre></a><a href="#remove-items-by"><pre class="button color--primary">remove-items-by</pre></a><a href="#remove-last-item"><pre class="button color--primary">remove-last-item</pre></a><a href="#remove-last-items"><pre class="button color--primary">remove-last-items</pre></a><a href="#remove-nth-item"><pre class="button color--primary">remove-nth-item</pre></a><a href="#remove-nth-items"><pre class="button color--primary">remove-nth-items</pre></a><a href="#repeat-item"><pre class="button color--primary">repeat-item</pre></a><a href="#replace-first-item"><pre class="button color--primary">replace-first-item</pre></a><a href="#replace-item"><pre class="button color--primary">replace-item</pre></a><a href="#replace-last-item"><pre class="button color--primary">replace-last-item</pre></a><a href="#replace-nth-item"><pre class="button color--primary">replace-nth-item</pre></a><a href="#replace-second-item"><pre class="button color--primary">replace-second-item</pre></a><a href="#result-count"><pre class="button color--primary">result-count</pre></a><a href="#reverse-items"><pre class="button color--primary">reverse-items</pre></a><a href="#second-dex-by"><pre class="button color--primary">second-dex-by</pre></a><a href="#second-item"><pre class="button color--primary">second-item</pre></a><a href="#second-match"><pre class="button color--primary">second-match</pre></a><a href="#second-result"><pre class="button color--primary">second-result</pre></a><a href="#similars"><pre class="button color--primary">similars</pre></a><a href="#sort-items"><pre class="button color--primary">sort-items</pre></a><a href="#sort-items-by"><pre class="button color--primary">sort-items-by</pre></a><a href="#sort-items-by-dexes"><pre class="button color--primary">sort-items-by-dexes</pre></a><a href="#sorted-dexes"><pre class="button color--primary">sorted-dexes</pre></a><a href="#suffix-items"><pre class="button color--primary">suffix-items</pre></a><a href="#sum-items"><pre class="button color--primary">sum-items</pre></a><a href="#sum-items-by"><pre class="button color--primary">sum-items-by</pre></a><a href="#to-associative"><pre class="button color--primary">to-associative</pre></a><a href="#to-first-match"><pre class="button color--primary">to-first-match</pre></a><a href="#to-first-occurence"><pre class="button color--primary">to-first-occurence</pre></a><a href="#to-last-match"><pre class="button color--primary">to-last-match</pre></a><a href="#to-last-occurence"><pre class="button color--primary">to-last-occurence</pre></a><a href="#to-map"><pre class="button color--primary">to-map</pre></a><a href="#to-nil"><pre class="button color--primary">to-nil</pre></a><a href="#to-seqable"><pre class="button color--primary">to-seqable</pre></a><a href="#toggle-item"><pre class="button color--primary">toggle-item</pre></a><a href="#update-all-item"><pre class="button color--primary">update-all-item</pre></a><a href="#update-first-item"><pre class="button color--primary">update-first-item</pre></a><a href="#update-first-item-by"><pre class="button color--primary">update-first-item-by</pre></a><a href="#update-items-by"><pre class="button color--primary">update-items-by</pre></a><a href="#update-last-item"><pre class="button color--primary">update-last-item</pre></a><a href="#update-last-item-by"><pre class="button color--primary">update-last-item-by</pre></a><a href="#update-nth-item"><pre class="button color--primary">update-nth-item</pre></a><a href="#update-nth-item-by"><pre class="button color--primary">update-nth-item-by</pre></a><a href="#update-second-item"><pre class="button color--primary">update-second-item</pre></a><a href="#update-second-item-by"><pre class="button color--primary">update-second-item-by</pre></a><a href="#upsert-first-item"><pre class="button color--primary">upsert-first-item</pre></a><a href="#upsert-last-item"><pre class="button color--primary">upsert-last-item</pre></a><a href="#upsert-nth-item"><pre class="button color--primary">upsert-nth-item</pre></a><a href="#upsert-second-item"><pre class="button color--primary">upsert-second-item</pre></a></div></div></div><div id="namespace-header"><pre class="text--bold" id="namespace-header--title">fruits.vector.api</pre><pre class="text--xs color--muted">Isomorphic namespace</pre></div><div id="tutorials--wrapper"><div id="tutorials"></div></div><div id="declarations--wrapper"><div id="declarations"><div class="declaration--wrapper" id="conj-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">conj-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Conjoins the given items to the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(conj-item [:a :b] :c)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(conj-item [:a :b] :c :d)<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="conj-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;conj-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn conj-item<br>  [n & xyz]<br>  (let [n (mixed/to-vector n)]<br>       (apply conj n xyz)))</pre></div></div><div class="declaration--wrapper" id="conj-item-once"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">conj-item-once</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Conjoins the given items to the given 'n' vector in case it doesn't contain them already.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(conj-item-once [:a :b] :b :c :d)<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="conj-item-once-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;conj-item-once-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn conj-item-once<br>  [n & xyz]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x]<br>                   (if (-> result (contain/contains-item? x))<br>                       (-> result)<br>                       (-> result (conj x))))]<br>              (reduce f0 n (vec xyz)))))</pre></div></div><div class="declaration--wrapper" id="conj-some"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">conj-some</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Conjoins the given items to the given 'n' vector in case the items are not NIL.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(conj-some [:a :b] :c nil)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="conj-some-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;conj-some-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn conj-some<br>  [n & xyz]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x]<br>                   (if x (-> result (conj x))<br>                         (-> result)))]<br>              (reduce f0 n (vec xyz)))))</pre></div></div><div class="declaration--wrapper" id="cons-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">cons-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Constructs a new vector where the given items are the first and the items of the given 'n' vector are the rest.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(cons-item [:a :b] :c :d :e)<br>=&gt;<br>[:e :d :c :a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="cons-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;cons-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn cons-item<br>  [n & xyz]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x] (cons x result))]<br>              (vec (reduce f0 n (vec xyz))))))</pre></div></div><div class="declaration--wrapper" id="cons-item-once"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">cons-item-once</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Constructs a new vector where the given items are the first and the items of the given 'n' vector are the rest<br>in case the 'n' vector doesn't contain them already.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(cons-item-once [:a :b] :b :c)<br>=&gt;<br>[:c :a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(cons-item-once [:a :b] :b :c :d :e)<br>=&gt;<br>[:e :d :c :a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="cons-item-once-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;cons-item-once-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn cons-item-once<br>  [n & xyz]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x]<br>                   (if (-> result (contain/contains-item? x))<br>                       (-> result)<br>                       (-> x (cons result))))]<br>              (vec (reduce f0 n (vec xyz))))))</pre></div></div><div class="declaration--wrapper" id="concat-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">concat-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Concatenates the given vectors into one.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">abc</pre><pre class="text--xs color--muted">list of vectors</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(concat-items [:a :b] [:c :d] [:e :f])<br>=&gt;<br>[:a :b :c :d :e :f]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="concat-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;concat-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn concat-items<br>  [& abc]<br>  (let [abc (map mixed/to-vector abc)]<br>       (vec (apply concat abc))))</pre></div></div><div class="declaration--wrapper" id="concat-items-once"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">concat-items-once</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Concatenates the given vectors into one without duplicating any item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">abc</pre><pre class="text--xs color--muted">list of vectors</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(concat-items-once [:a :b :c] [:c :d :e :a])<br>=&gt;<br>[:b :c :d :e :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="concat-items-once-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;concat-items-once-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn concat-items-once<br>  [& abc]<br>  (let [abc (map mixed/to-vector abc)]<br>       (-> (apply concat abc) set vec)))</pre></div></div><div class="declaration--wrapper" id="empty_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">empty?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is an empty vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? [])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? [:a])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? {})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="empty_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;empty_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn empty?<br>  [n]<br>  (and (-> n vector?)<br>       (-> n clojure.core/empty?)))</pre></div></div><div class="declaration--wrapper" id="not-empty_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-empty?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is a nonempty vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? [:a])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? [])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? {:a "A"})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-empty_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-empty_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-empty?<br>  [n]<br>  (and (-> n vector?)<br>       (-> n clojure.core/empty? not)))</pre></div></div><div class="declaration--wrapper" id="similars"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">similars</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the items that are present in both the given 'a' and 'b' vectors.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(similars [:a :b :c] [:c :d :e])<br>=&gt;<br>[:c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="similars-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;similars-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn similars<br>  [a b]<br>  (let [a (mixed/to-vector a)<br>        b (mixed/to-vector b)]<br>       (letfn [(f0 [result x]<br>                   (if (contain/contains-item? b x)<br>                       (conj result x)<br>                       (->   result)))]<br>              (reduce f0 [] a))))</pre></div></div><div class="declaration--wrapper" id="contains-similars_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-similars?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if there are items that are present in both the given 'a' and 'b' vectors.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-similars? [:a :b :c] [:c :d :e])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-similars? [:a :b :c] [:d :e :f])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-similars_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-similars_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-similars?<br>  [a b]<br>  (-> (similars a b) empty? not))</pre></div></div><div class="declaration--wrapper" id="difference"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">difference</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the items of the given 'a' vector that are not present in the given 'b' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(difference [:a :b :c] [:b :c])<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="difference-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;difference-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn difference<br>  [a b]<br>  (remove/remove-items a b))</pre></div></div><div class="declaration--wrapper" id="contains-item_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-item?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'x' value is present in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-item? [:a :b] :a)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-item? [:a :b] :c)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-item_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-item_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-item?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [%] (= % x))]<br>              (-> (some f0 n) boolean))))</pre></div></div><div class="declaration--wrapper" id="not-contains-item_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-contains-item?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'x' value is NOT present in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-contains-item? [:a :b] :c)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-contains-item? [:a :b] :a)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-contains-item_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-contains-item_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-contains-item?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [%] (not= % x))]<br>              (every? f0 n))))</pre></div></div><div class="declaration--wrapper" id="from-subvec"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">from-subvec</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' subvector into vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">subvec</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(from-subvec (subvec [:a :b :c] 1))<br>=&gt;<br>[:b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="from-subvec-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;from-subvec-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn from-subvec<br>  [n]<br>  (if (-> n coll?)<br>      (-> [] (into n))<br>      (-> [])))</pre></div></div><div class="declaration--wrapper" id="to-map"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-map</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' vector into map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">convert-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">Takes an index of a vector item and the corresponding item as parameters.<br>Must return a map key and value pair within a vector.<br>Default: (fn [dex x] [dex x])</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-map [:a :b :c])<br>=&gt;<br>{0 :a 1 :b 2 :c}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-map [:a :b :c] (fn [dex x] [(str dex) (name x)]))<br>=&gt;<br>{"0" "a" "1" "b" "2" "c"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-map-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-map-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-map<br>  ([n]<br>   (to-map n (fn [dex x] [dex x])))<br><br>  ([n convert-f]<br>   (let [n         (mixed/to-vector n)<br>         convert-f (mixed/to-ifn convert-f)]<br>        (letfn [(f0 [result dex x]<br>                    (let [kv (convert-f dex x)]<br>                         (if (mixed/kv? kv)<br>                             (-> result (assoc (first kv) (second kv)))<br>                             (-> result))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="to-nil"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-nil</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' vector into NIL.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:if-empty? (boolean)(opt)<br>  Converts only if the given 'n' vector is empty.<br>  Default: true}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-nil [])<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-nil [:a :b :c])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">nil or vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-nil-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-nil-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-nil<br>  ([n]<br>   (to-nil n {}))<br><br>  ([n {:keys [if-empty?] :or {if-empty? true} :as options}]<br>   (let [n (mixed/to-vector n)]<br>        (cond (-> n empty?)       (-> nil)<br>              (-> if-empty? not)  (-> nil)<br>              :return n))))</pre></div></div><div class="declaration--wrapper" id="to-associative"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-associative</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' value into vector, in case it does not implement the IAssociative protocol.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative {:a "A"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative [:a :b :c])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative nil)<br>=&gt;<br>[]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative "abc")<br>=&gt;<br>["abc"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative 123)<br>=&gt;<br>[123]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector or associative *</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-associative-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-associative-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-associative<br>  [n]<br>  (cond (-> n associative?) (-> n)<br>        (-> n nil?)         (-> [])<br>        :else               (-> [n])))</pre></div></div><div class="declaration--wrapper" id="to-seqable"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-seqable</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' value into vector, in case it does not implement the ISeqable protocol.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable {:a "A"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable [:a :b :c])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable nil)<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable "abc")<br>=&gt;<br>"abc"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable 123)<br>=&gt;<br>[123]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map or seqable *</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-seqable-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-seqable-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-seqable<br>  [n]<br>  (if (-> n seqable?)<br>      (-> n)<br>      (-> [n])))</pre></div></div><div class="declaration--wrapper" id="count_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' vector has as many items as the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count? [:a :b :c] 3)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n count (= x))))</pre></div></div><div class="declaration--wrapper" id="count-min_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count-min?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' vector has at least as many items as the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-min? [:a :b :c] 3)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-min? [:a :b] 3)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count-min_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count-min_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count-min?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n count (>= x))))</pre></div></div><div class="declaration--wrapper" id="count-max_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count-max?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' vector has at most as many items as the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-max? [:a :b :c] 3)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-max? [:a :b :c :d] 3)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count-max_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count-max_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count-max?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n count (<= x))))</pre></div></div><div class="declaration--wrapper" id="count-same_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count-same?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given vectors have the same item count.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">abc</pre><pre class="text--xs color--muted">list of vectors</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-same? [:a :b :c] [:a :b :c])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-same? [:a :b :c] [:a :b :c :d])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count-same_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count-same_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count-same?<br>  [& abc]<br>  (let [abc (map mixed/to-vector abc)]<br>       (loop [sample nil dex 0]<br>             (cond (seqable/dex-out-of-bounds? abc dex) (-> true)<br>                   (-> sample nil?)                     (recur (-> abc (nth dex) count) (inc dex))<br>                   (-> abc (nth dex) count (= sample))  (recur (-> abc (nth dex) count) (inc dex))<br>                   :else false))))</pre></div></div><div class="declaration--wrapper" id="count-inc_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count-inc?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given vectors are provided in increasing order of their item count.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">abc</pre><pre class="text--xs color--muted">list of vectors</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-inc? [:a :b :c] [:a :b :c :d])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-inc? [:a :b :c :d] [:a :b :c])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count-inc_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count-inc_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count-inc?<br>  [& abc]<br>  (let [abc (map mixed/to-vector abc)]<br>       (loop [sample nil dex 0]<br>             (cond (seqable/dex-out-of-bounds? abc dex) (-> true)<br>                   (-> sample nil?)                     (recur (-> abc (nth dex) count) (inc dex))<br>                   (-> abc (nth dex) count (> sample))  (recur (-> abc (nth dex) count) (inc dex))<br>                   :else false))))</pre></div></div><div class="declaration--wrapper" id="count-dec_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">count-dec?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given vectors are provided in decreasing order of their item count.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">abc</pre><pre class="text--xs color--muted">list of vectors</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-dec? [:a :b :c :d] [:a :b :c])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(count-dec? [:a :b :c] [:a :b :c :d])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="count-dec_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;count-dec_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn count-dec?<br>  [& abc]<br>  (let [abc (map mixed/to-vector abc)]<br>       (loop [sample nil dex 0]<br>             (cond (seqable/dex-out-of-bounds? abc dex) (-> true)<br>                  (-> sample nil?)                     (recur (-> abc (nth dex) count) (inc dex))<br>                  (-> abc (nth dex) count (< sample))  (recur (-> abc (nth dex) count) (inc dex))<br>                  :else false))))</pre></div></div><div class="declaration--wrapper" id="keep-range"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-range</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps the items of the given 'n' vector that fall into the given range.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">from</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-range [:a :b :c :d :e :f] 1 3)<br>=&gt;<br>[:b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-range [:a :b :c :d :e :f] 2)<br>=&gt;<br>[:c :d :e :f]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-range-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-range-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-range<br>  ([n from]<br>   (let [to (count n)]<br>        (keep-range n from to)))<br><br>  ([n from to]<br>   (let [n    (mixed/to-vector n)<br>         from (seqable/normalize-cursor n from {:adjust? true :mirror? true})<br>         to   (seqable/normalize-cursor n to   {:adjust? true :mirror? true})]<br>        (into [] (subvec n (min from to)<br>                           (max from to))))))</pre></div></div><div class="declaration--wrapper" id="cut-range"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">cut-range</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the items of the given 'n' vector that don't fall into the given range.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">from</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(cut-range [:a :b :c :d :e :f] 1 3)<br>=&gt;<br>[:a :d :e :f]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(cut-range [:a :b :c :d :e :f] 2)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="cut-range-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;cut-range-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn cut-range<br>  ([n from]<br>   (let [to (count n)]<br>        (cut-range n from to)))<br><br>  ([n from to]<br>   (let [n    (mixed/to-vector n)<br>         from (seqable/normalize-cursor n from {:adjust? true :mirror? true})<br>         to   (seqable/normalize-cursor n to   {:adjust? true :mirror? true})]<br>        (vec (concat (subvec n 0 (min from to))<br>                     (subvec n   (max from to)))))))</pre></div></div><div class="declaration--wrapper" id="keep-last-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-last-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a vector that contains the last specific amount of items of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">length</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-last-items [:a :b :c :d :e] 2)<br>=&gt;<br>[:d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-last-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-last-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-last-items<br>  [n length]<br>  (let [n      (mixed/to-vector n)<br>        length (seqable/normalize-cursor n length {:adjust? true :mirror? false})]<br>       (into [] (subvec n (-> n count (- length))))))</pre></div></div><div class="declaration--wrapper" id="keep-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a vector that contains the last item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-last-item [:a :b :c])<br>=&gt;<br>[:c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-last-item [nil nil nil])<br>=&gt;<br>[nil]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-last-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n count (= 1))<br>           (-> n)<br>           (if-let [last-item (-> n last)]<br>                   [last-item] []))))</pre></div></div><div class="declaration--wrapper" id="keep-first-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-first-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a vector that contains the first specific amount of items of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">length</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-first-items [:a :b :c :d :e] 3)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-first-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-first-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-first-items<br>  [n length]<br>  (let [n      (mixed/to-vector n)<br>        length (seqable/normalize-cursor n length {:adjust? true :mirror? false})]<br>       (into [] (subvec n 0 length))))</pre></div></div><div class="declaration--wrapper" id="keep-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a vector that contains the first item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-first-item [:a :b :c])<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-first-item [nil nil nil])<br>=&gt;<br>[nil]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-first-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n count (= 1))<br>           (-> n)<br>           (if-let [first-item (-> n first)]<br>                   [first-item] []))))</pre></div></div><div class="declaration--wrapper" id="before-first-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">before-first-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(before-first-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="before-first-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;before-first-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn before-first-occurence<br>  ([n x]<br>   (before-first-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-first-dex (dex/first-dex-of n x)]<br>                (into [] (subvec n 0 item-first-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="before-first-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">before-first-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(before-first-match [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="before-first-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;before-first-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn before-first-match<br>  ([n f]<br>   (before-first-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-first-dex (dex/first-dex-by n f)]<br>                (into [] (subvec n 0 item-first-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="before-last-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">before-last-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(before-last-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="before-last-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;before-last-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn before-last-occurence<br>  ([n x]<br>   (before-last-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-last-dex (dex/last-dex-of n x)]<br>                (into [] (subvec n 0 item-last-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="before-last-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">before-last-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(before-last-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="before-last-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;before-last-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn before-last-match<br>  ([n f]<br>   (before-last-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-last-dex (dex/last-dex-by n f)]<br>                (into [] (subvec n 0 item-last-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="after-first-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">after-first-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(after-first-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:d :c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="after-first-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;after-first-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn after-first-occurence<br>  ([n x]<br>   (after-first-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-first-dex (dex/first-dex-of n x)]<br>                (if (number? item-first-dex)<br>                    (into [] (subvec n (inc item-first-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="after-first-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">after-first-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(after-first-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:d :c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="after-first-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;after-first-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn after-first-match<br>  ([n f]<br>   (after-first-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-first-dex (dex/first-dex-by n f)]<br>                (if (number? item-first-dex)<br>                    (into [] (subvec n (inc item-first-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="after-last-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">after-last-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(after-last-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="after-last-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;after-last-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn after-last-occurence<br>  ([n x]<br>   (after-last-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-last-dex (dex/last-dex-of n x)]<br>                (if (number? item-last-dex)<br>                    (into [] (subvec n (inc item-last-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="after-last-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">after-last-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(after-last-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="after-last-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;after-last-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn after-last-match<br>  ([n f]<br>   (after-last-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-last-dex (dex/last-dex-by n f)]<br>                (if (number? item-last-dex)<br>                    (into [] (subvec n (inc item-last-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="from-first-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">from-first-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(from-first-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:c :d :c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="from-first-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;from-first-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn from-first-occurence<br>  ([n x]<br>   (from-first-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-first-dex (dex/first-dex-of n x)]<br>                (into [] (subvec n item-first-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="from-first-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">from-first-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(from-first-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:c :d :c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="from-first-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;from-first-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn from-first-match<br>  ([n f]<br>   (from-first-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-first-dex (dex/first-dex-by n f)]<br>                (into [] (subvec n item-first-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="from-last-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">from-last-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(from-last-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="from-last-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;from-last-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn from-last-occurence<br>  ([n x]<br>   (from-last-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-last-dex (dex/last-dex-of n x)]<br>                (into [] (subvec n item-last-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="from-last-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">from-last-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(from-last-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="from-last-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;from-last-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn from-last-match<br>  ([n f]<br>   (from-last-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-last-dex (dex/last-dex-by n f)]<br>                (into [] (subvec n item-last-dex))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="to-first-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-first-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-first-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-first-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-first-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-first-occurence<br>  ([n x]<br>   (to-first-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-first-dex (dex/first-dex-of n x)]<br>                (if (number? item-first-dex)<br>                    (into [] (subvec n 0 (inc item-first-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="to-first-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-first-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-first-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-first-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-first-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-first-match<br>  ([n f]<br>   (to-first-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-first-dex (dex/first-dex-by n f)]<br>                (if (number? item-first-dex)<br>                    (into [] (subvec n 0 (inc item-first-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="to-last-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-last-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no occurence is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-last-occurence [:a :b :c :d :c :b :a] :c)<br>=&gt;<br>[:a :b :c :d :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-last-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-last-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-last-occurence<br>  ([n x]<br>   (to-last-occurence n x {}))<br><br>  ([n x {:keys [return?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [item-last-dex (dex/last-dex-of n x)]<br>                (if (number? item-last-dex)<br>                    (into [] (subvec n 0 (inc item-last-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="to-last-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-last-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:return? (boolean)(opt)<br>  If TRUE, returns the given 'n' vector in case of no match is found.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-last-match [:a :b :c :d :c :b :a] #(= % :c))<br>=&gt;<br>[:a :b :c :d :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-last-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-last-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-last-match<br>  ([n f]<br>   (to-last-match n f {}))<br><br>  ([n f {:keys [return?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn    f)]<br>        (if-let [item-last-dex (dex/last-dex-by n f)]<br>                (if (number? item-last-dex)<br>                    (into [] (subvec n 0 (inc item-last-dex))))<br>                (if return? n [])))))</pre></div></div><div class="declaration--wrapper" id="first-dex-of"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-dex-of</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the first occurence of the given 'x' item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-dex-of [:a :b :a :b] :b)<br>=&gt;<br>1</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-dex-of-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-dex-of-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-dex-of<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (loop [dex 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> x (= (nth n dex))) (-> dex)<br>                       :recur                 (-> dex inc recur))))))</pre></div></div><div class="declaration--wrapper" id="last-dex-of"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">last-dex-of</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the last occurence of the given 'x' item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-dex-of [:a :b :a :b] :b)<br>=&gt;<br>3</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="last-dex-of-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;last-dex-of-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn last-dex-of<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (loop [dex (-> n count dec)]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> x (= (nth n dex))) (-> dex)<br>                       :recur                 (-> dex dec recur))))))</pre></div></div><div class="declaration--wrapper" id="nth-dex-of"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">nth-dex-of</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the nth occurence of the given 'x' item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-dex-of [:a :b :a :b :a :b] :b 1)<br>=&gt;<br>3</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="nth-dex-of-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;nth-dex-of-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn nth-dex-of<br>  [n x th]<br>  (let [n  (mixed/to-vector n)<br>        th (mixed/to-integer th)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> x (not= (nth n dex))) (recur (inc dex) match-count)<br>                       (= th (inc match-count))  (-> dex)<br>                       :recur-after-match        (recur (inc dex) (inc match-count)))))))</pre></div></div><div class="declaration--wrapper" id="first-dex-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-dex-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the first match of the given 'test-f' predicate function in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-dex-by ["a" :b :c :d] keyword?)<br>=&gt;<br>1</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-dex-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-dex-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-dex-by<br>  [n test-f]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)]<br>       (loop [dex 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) test-f) (-> dex)<br>                       :recur                  (-> dex inc recur))))))</pre></div></div><div class="declaration--wrapper" id="second-dex-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">second-dex-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the second match of the given 'test-f' predicate function in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(second-dex-by ["a" :b :c :d] keyword?)<br>=&gt;<br>2</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="second-dex-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;second-dex-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn second-dex-by<br>  [n test-f]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) test-f not) (recur (inc dex) match-count)<br>                       (=  2 (inc match-count))    (-> dex)<br>                       :recur-after-match          (recur (inc dex) (inc match-count)))))))</pre></div></div><div class="declaration--wrapper" id="last-dex-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">last-dex-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the last match of the given 'test-f' predicate function in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-dex-by [:a :b :c "b"] keyword?)<br>=&gt;<br>3</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="last-dex-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;last-dex-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn last-dex-by<br>  [n test-f]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)]<br>       (loop [dex (-> n count dec)]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) test-f) (-> dex)<br>                       :recur                  (-> dex dec recur))))))</pre></div></div><div class="declaration--wrapper" id="nth-dex-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">nth-dex-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the index of the nth match of the given 'test-f' predicate function in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-dex-by ["a" :b :c :d] keyword? 1)<br>=&gt;<br>2</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="nth-dex-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;nth-dex-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn nth-dex-by<br>  [n test-f th]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        th     (mixed/to-integer th)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) test-f not) (recur (inc dex) match-count)<br>                       (= th (inc match-count))    (-> dex)<br>                       :recur-after-match          (recur (inc dex) (inc match-count)))))))</pre></div></div><div class="declaration--wrapper" id="duplicate-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">duplicate-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates the first item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(duplicate-first-item [:a :b :c :d :e])<br>=&gt;<br>[:a :a :b :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="duplicate-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;duplicate-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn duplicate-first-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n count (>= 1))<br>           (-> n first (cons n) vec)<br>           (-> n))))</pre></div></div><div class="declaration--wrapper" id="duplicate-second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">duplicate-second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates the second item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(duplicate-second-item [:a :b :c :d :e])<br>=&gt;<br>[:a :b :b :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="duplicate-second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;duplicate-second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn duplicate-second-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n count (>= 2))<br>           (vec (concat (subvec n 0 1)<br>                        [(second n)]<br>                        (subvec n 1)))<br>           (-> n))))</pre></div></div><div class="declaration--wrapper" id="duplicate-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">duplicate-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates the last item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(duplicate-last-item [:a :b :c :d :e])<br>=&gt;<br>[:a :b :c :d :e :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="duplicate-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;duplicate-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn duplicate-last-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (if (->  n count (>= 1))<br>           (->> n last (conj n) vec)<br>           (->  n))))</pre></div></div><div class="declaration--wrapper" id="duplicate-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">duplicate-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates the nth item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(duplicate-nth-item [:a :b :c :d :e] 2)<br>=&gt;<br>[:a :b :c :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="duplicate-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;duplicate-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn duplicate-nth-item<br>  [n th]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (vec (concat (subvec n 0 th)<br>                            [(nth n th)]<br>                            (subvec n th)))<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="duplicate-nth-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">duplicate-nth-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Important</pre></div><pre class="text--m color--warning">This function is incomplete and may not behave as expected.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates the nth items in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ths</pre><pre class="text--xs color--muted">integers in vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(duplicate-nth-items [:a :b :c :d :e] [0 2])<br>=&gt;<br>[:a :a :b :c :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="duplicate-nth-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;duplicate-nth-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn duplicate-nth-items<br>  [n ths])</pre></div></div><div class="declaration--wrapper" id="first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-item [:a :b :c])<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (first n)))</pre></div></div><div class="declaration--wrapper" id="second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-item [:a :b :c])<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn second-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (second n)))</pre></div></div><div class="declaration--wrapper" id="last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the last item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-item [:a :b :c])<br>=&gt;<br>:c</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn last-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (last n)))</pre></div></div><div class="declaration--wrapper" id="nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the nth item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-item [:a :b :c] 2)<br>=&gt;<br>:c</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn nth-item<br>  [n th]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (nth n th))))</pre></div></div><div class="declaration--wrapper" id="insert-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">insert-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Inserts the given 'x' value into the given 'n' vector to a specific position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">cursor</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(insert-item [:a :b :c] 2 :d)<br>=&gt;<br>[:a :b :d :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(insert-item [:a :b :c] 999 :d)<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(insert-item nil 999 :d)<br>=&gt;<br>[:d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(insert-item {:a "b"} 1 :d)<br>=&gt;<br>[:d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="insert-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;insert-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn insert-item<br>  [n cursor x]<br>  (let [n      (mixed/to-vector n)<br>        cursor (seqable/normalize-cursor n cursor {:adjust? true :mirror? true})]<br>       (vec (concat (subvec n 0 cursor)<br>                    [x]<br>                    (subvec n cursor)))))</pre></div></div><div class="declaration--wrapper" id="item-only_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">item-only?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-only? [:b] :b)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-only? [:a :b] :b)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="item-only_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;item-only_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn item-only?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (= n [x])))</pre></div></div><div class="declaration--wrapper" id="item-first_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">item-first?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-first? [:a :b] :a)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="item-first_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;item-first_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn item-first?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n first (= x))))</pre></div></div><div class="declaration--wrapper" id="item-second_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">item-second?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-second? [:a :b] :b)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="item-second_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;item-second_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn item-second?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n second (= x))))</pre></div></div><div class="declaration--wrapper" id="item-last_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">item-last?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-last? [:a :b] :b)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="item-last_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;item-last_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn item-last?<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (-> n last (= x))))</pre></div></div><div class="declaration--wrapper" id="item-nth_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">item-nth?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(item-nth? [:a :b] :b 1)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="item-nth_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;item-nth_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn item-nth?<br>  [n x th]<br>  (let [n  (mixed/to-vector n)<br>        th (mixed/to-integer th)]<br>       (if (-> n count (>= th))<br>           (-> n (nth th) (= x)))))</pre></div></div><div class="declaration--wrapper" id="any-item-matches_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">any-item-matches?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if any item in the given 'n' vector matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-item-matches? [:a "b" :c] string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-item-matches? [:a :b :c] string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="any-item-matches_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;any-item-matches_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn any-item-matches?<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (-> (some f n) boolean)))</pre></div></div><div class="declaration--wrapper" id="no-item-matches_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">no-item-matches?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if no item in the given 'n' vector matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(no-item-matches? [:a :b :c] string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(no-item-matches? [:a "b" :c] string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="no-item-matches_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;no-item-matches_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn no-item-matches?<br>  [n f]<br>  (-> (any-item-matches? n f) not))</pre></div></div><div class="declaration--wrapper" id="all-items-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">all-items-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if every item in the given 'n' vector matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-items-match? ["a" "b" "c"] string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-items-match? [:a "b" "c"] string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="all-items-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;all-items-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn all-items-match?<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (every? f n)))</pre></div></div><div class="declaration--wrapper" id="not-all-items-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-all-items-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if not every item in the given 'n' vector matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-items-match? [:a "b" "c"] string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-items-match? ["a" "b" "c"] string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-all-items-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-all-items-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-all-items-match?<br>  [n f]<br>  (-> (all-items-match? n f) not))</pre></div></div><div class="declaration--wrapper" id="first-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first item in the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-match [:a :b :c "d"] keyword?)<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-match<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) f) (-> n (nth dex))<br>                       :recur             (-> dex inc recur))))))</pre></div></div><div class="declaration--wrapper" id="second-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">second-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the second item in the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(second-match [:a :b :c "d"] keyword?)<br>=&gt;<br>:b</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="second-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;second-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn second-match<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) f not) (-> dex inc (recur match-count))<br>                       (-> 2 (= match-count)) (-> n (nth dex))<br>                       :recur-after-match     (-> dex inc (recur (inc match-count))))))))</pre></div></div><div class="declaration--wrapper" id="last-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">last-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the last item in the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-match [:a :b :c "d"] keyword?)<br>=&gt;<br>:c</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="last-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;last-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn last-match<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex (-> n count dec)]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) f) (-> n (nth dex))<br>                       :recur             (-> dex dec recur))))))</pre></div></div><div class="declaration--wrapper" id="nth-match"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">nth-match</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the nth item in the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-match [:a :b :c "d"] keyword? 1)<br>=&gt;<br>:b</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="nth-match-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;nth-match-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn nth-match<br>  [n f th]<br>  (let [n  (mixed/to-vector n)<br>        f  (mixed/to-ifn f)<br>        th (mixed/to-integer th)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (cond (-> n (nth dex) f not)  (-> dex inc (recur match-count))<br>                       (-> th (= match-count)) (-> n (nth dex))<br>                       :recur-after-match      (-> dex inc (recur (inc match-count))))))))</pre></div></div><div class="declaration--wrapper" id="all-matches"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">all-matches</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns all items in the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-matches [:a :b :c "d"] keyword?)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="all-matches-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;all-matches-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn all-matches<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [matches x]<br>                   (if (-> x f)<br>                       (-> matches conj x)<br>                       (-> matches)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="match-count"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">match-count</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns how many items in the given 'n' vector matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(match-count [:a :b "c"] keyword?)<br>=&gt;<br>2</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="match-count-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;match-count-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn match-count<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (count (filter f n))))</pre></div></div><div class="declaration--wrapper" id="move-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the first item in the given 'n' vector to a specific cursor position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-first-item [:a :b :c :d :e :f :g :h] 3)<br>=&gt;<br>[:b :c :d :a :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-first-item<br>  [n to]<br>  (let [n  (mixed/to-vector n)<br>        to (seqable/normalize-dex n to {:adjust? true :mirror? true})]<br>       (if (-> n count (>= 1))<br>           (cond <br>                 (-> to (= 0))<br>                 (-> n)<br>                 (-> to (> 0))<br>                 (vec (concat (subvec n 1 (inc to))<br>                              [(first n)]<br>                              (subvec n (inc to)))))<br>           (-> n))))</pre></div></div><div class="declaration--wrapper" id="move-second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the second item in the given 'n' vector to a specific cursor position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-second-item [:a :b :c :d :e :f :g :h] 3)<br>=&gt;<br>[:a :c :d :b :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-second-item<br>  [n to]<br>  (let [n  (mixed/to-vector n)<br>        to (seqable/normalize-dex n to {:adjust? true :mirror? true})]<br>       (if (-> n count (>= 2))<br>           (cond <br>                 (-> to (= 1))<br>                 (-> n)<br>                 (-> to (= 0))<br>                 (vec (concat [(second n) (first n)]<br>                              (subvec n 2)))<br>                 (-> to (> 1))<br>                 (vec (concat [(first n)]<br>                              (subvec n 2 (inc to))<br>                              [(second n)]<br>                              (subvec n (inc to)))))<br>           (-> n))))</pre></div></div><div class="declaration--wrapper" id="move-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the last item in the given 'n' vector to a specific cursor position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-last-item [:a :b :c :d :e :f :g :h] 3)<br>=&gt;<br>[:a :b :c :h :d :e :f :g]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-last-item<br>  [n to]<br>  (let [n  (mixed/to-vector n)<br>        to (seqable/normalize-dex n to {:adjust? true :mirror? true})]<br>       (if (-> n count (>= 1))<br>           (cond <br>                 (-> n count dec (= to))<br>                 (-> n)<br>                 (-> n count dec (> to))<br>                 (vec (concat (subvec n 0 to)<br>                              [(last n)]<br>                              (subvec n to (-> n count dec)))))<br>           (-> n))))</pre></div></div><div class="declaration--wrapper" id="move-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the nth item in the given 'n' vector to a specific cursor position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">from</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item [:a :b :c :d :e :f :g :h] 2 2)<br>=&gt;<br>[:a :b :c :d :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item [:a :b :c :d :e :f :g :h] 2 5)<br>=&gt;<br>[:a :b :d :e :f :c :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item [:a :b :c :d :e :f :g :h] 5 2)<br>=&gt;<br>[:a :b :f :c :d :e :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-nth-item<br>  [n from to]<br>  (let [n  (mixed/to-vector n)<br>        to (seqable/normalize-dex n to {:adjust? true :mirror? true})]<br>       (if-let [from (seqable/normalize-dex n from {:adjust? false :mirror? true})]<br>               (cond <br>                     (= from to)<br>                     (-> n)<br>                     (< from to)<br>                     (vec (concat (subvec n 0 from)<br>                                  (subvec n (inc from) (inc to))<br>                                  (subvec n from (inc from))<br>                                  (subvec n (inc to))))<br>                     (> from to)<br>                     (vec (concat (subvec n 0 to)<br>                                  (subvec n from (inc from))<br>                                  (subvec n to from)<br>                                  (subvec n (inc from)))))<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="move-nth-item-bwd"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-nth-item-bwd</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the nth item in the given 'n' vector backwards.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">step</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">Default: 1</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item-bwd [:a :b :c :d] 2)<br>=&gt;<br>[:a :c :b :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item-bwd [:a :b :c :d] 0)<br>=&gt;<br>[:b :c :d :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-nth-item-bwd-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-nth-item-bwd-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-nth-item-bwd<br>  ([n th]<br>   (move-nth-item-bwd n th 1))<br><br>  ([n th step]<br>   (let [th   (mixed/to-integer th)<br>         step (mixed/to-integer step)]<br>        (move-nth-item n th (- th step)))))</pre></div></div><div class="declaration--wrapper" id="move-nth-item-fwd"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-nth-item-fwd</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the nth item in the given 'n' vector forwards.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">step</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">Default: 1</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item-fwd [:a :b :c :d] 2)<br>=&gt;<br>[:a :b :d :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-nth-item-fwd [:a :b :c :d] 3)<br>=&gt;<br>[:d :a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-nth-item-fwd-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-nth-item-fwd-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-nth-item-fwd<br>  ([n th]<br>   (move-nth-item-fwd n th 1))<br><br>  ([n th step]<br>   (let [th   (mixed/to-integer th)<br>         step (mixed/to-integer step)]<br>        (move-nth-item n th (+ th step)))))</pre></div></div><div class="declaration--wrapper" id="move-item-to-first"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-item-to-first</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the first occurence of a specific item in the given 'n' vector to the first position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:insert? (boolean)(opt)<br>  Inserts the item in case the given 'n' vector doesn't contain it.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-item-to-first [:a :b :c :d :e :f :g :h] :b)<br>=&gt;<br>[:b :a :c :d :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-item-to-first-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-item-to-first-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-item-to-first<br>  ([n x]<br>   (move-item-to-first n x {}))<br><br>  ([n x {:keys [insert?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [dex (dex/first-dex-of n x)]<br>                (move-nth-item n dex 0)<br>                (if insert? (-> n (add/cons-item x))<br>                            (-> n))))))</pre></div></div><div class="declaration--wrapper" id="move-item-to-second"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-item-to-second</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the first occurence of a specific item in the given 'n' vector to the second position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:insert? (boolean)(opt)<br>  Inserts the item in case the given 'n' vector doesn't contain it.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-item-to-second [:a :b :c :d :e :f :g :h] :a)<br>=&gt;<br>[:b :a :c :d :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-item-to-second-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-item-to-second-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-item-to-second<br>  ([n x]<br>   (move-item-to-second n x {}))<br><br>  ([n x {:keys [insert?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [dex (dex/first-dex-of n x)]<br>                (move-nth-item n dex 1)<br>                (if insert? (-> n (insert/insert-item 1 x))<br>                            (-> n))))))</pre></div></div><div class="declaration--wrapper" id="move-item-to-last"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-item-to-last</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the first occurence of a specific item in the given 'n' vector to the last position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:insert? (boolean)(opt)<br>  Inserts the item in case the given 'n' vector doesn't contain it.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-item-to-last [:a :b :c :d :e :f :g :h] :a)<br>=&gt;<br>[:b :c :d :e :f :g :h :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-item-to-last-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-item-to-last-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-item-to-last<br>  ([n x]<br>   (move-item-to-last n x {}))<br><br>  ([n x {:keys [insert?]}]<br>   (let [n (mixed/to-vector n)]<br>        (if-let [dex (dex/first-dex-of n x)]<br>                (move-nth-item n dex -1)<br>                (if insert? (-> n (add/conj-item x))<br>                            (-> n))))))</pre></div></div><div class="declaration--wrapper" id="move-item-to-nth"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-item-to-nth</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves the first occurence of a specific item in the given 'n' vector to the nth position.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:insert? (boolean)(opt)<br>  Inserts the item in case the given 'n' vector doesn't contain it.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-item-to-nth [:a :b :c :d :e :f :g :h] :a 2)<br>=&gt;<br>[:b :c :a :d :e :f :g :h]</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">(... [:a :b :c] :c 5)</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-item-to-nth-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-item-to-nth-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-item-to-nth<br>  ([n x to]<br>   (move-item-to-nth n x to {}))<br><br>  ([n x to {:keys [insert?]}]<br>   (let [n  (mixed/to-vector n)<br>         to (seqable/normalize-dex n to {:adjust? true :mirror? true})]<br>        (if-let [dex (dex/first-dex-of n x)]<br>                (move-nth-item n dex to)<br>                (if insert? (-> n (insert/insert-item to x))<br>                            (-> n))))))</pre></div></div><div class="declaration--wrapper" id="remove-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">dex</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-item [:a :b] :b)<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-item [:a :b :a] :a)<br>=&gt;<br>[:b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [%] (= % x))]<br>              (vec (remove f0 n)))))</pre></div></div><div class="declaration--wrapper" id="remove-item-once"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-item-once</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">dex</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-item-once [:a :b :b] :b)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-item-once [:a :b :a] :a)<br>=&gt;<br>[:b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-item-once-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-item-once-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-item-once<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (loop [dex 0]<br>             (cond (seqable/dex-out-of-bounds? n dex) (-> n)<br>                   (not= x (nth n dex))               (-> dex inc recur)<br>                   :return (vec (concat (subvec n 0 dex)<br>                                        (if-not (seqable/dex-last? n dex)<br>                                                (subvec n (inc dex)))))))))</pre></div></div><div class="declaration--wrapper" id="remove-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the first item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-first-item [:a :b :c :d :e])<br>=&gt;<br>[:b :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-first-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (vec (drop 1 n))))</pre></div></div><div class="declaration--wrapper" id="remove-first-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-first-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes a specific amount of items from the beginning of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">cut</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-first-items [:a :b :c :d :e] 2)<br>=&gt;<br>[:c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-first-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-first-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-first-items<br>  [n cut]<br>  (let [n   (mixed/to-vector n)<br>        cut (mixed/to-integer cut)]<br>       (cond (-> n count (<= cut)) (-> [])<br>             :return (into [] (subvec n cut)))))</pre></div></div><div class="declaration--wrapper" id="remove-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the last item of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-last-item [:a :b :c :d :e])<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-last-item<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (-> n drop-last vec)))</pre></div></div><div class="declaration--wrapper" id="remove-last-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-last-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes a specific amount of items from the end of the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">cut</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-last-items [:a :b :c :d :e] 2)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-last-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-last-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-last-items<br>  [n cut]<br>  (let [n   (mixed/to-vector n)<br>        cut (mixed/to-integer cut)]<br>       (cond (-> n count (<= cut)) (-> [])<br>             :return (into [] (subvec n 0 (-> n count (- cut)))))))</pre></div></div><div class="declaration--wrapper" id="remove-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the nth item from the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-nth-item [:a :b :c :d :e] 2)<br>=&gt;<br>[:a :b :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-nth-item<br>  [n th]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (vec (concat (subvec n 0 th)<br>                            (subvec n (inc th))))<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="remove-nth-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-nth-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the nth items from the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ths</pre><pre class="text--xs color--muted">integers in vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-nth-items [:a :b :c :d :e] [0 2])<br>=&gt;<br>[:b :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-nth-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-nth-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-nth-items<br>  [n ths]<br>  (let [n   (mixed/to-vector n)<br>        ths (mixed/to-vector ths)<br>        ths (map mixed/to-integer ths)]<br>       (letfn [(f0 [result dex x]<br>                   (if (contain/contains-item? ths dex)<br>                       (->   result)<br>                       (conj result x)))]<br>              (reduce-kv f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="remove-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes items from the given 'n' vector that are present in the given 'xyz' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-items [:a :b :c] [:b :c])<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-items [:a :b :b :c ] [:b :c])<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-items<br>  [n xyz]<br>  (let [n   (mixed/to-vector n)<br>        xyz (mixed/to-vector xyz)]<br>       (vec (remove (set xyz) n))))</pre></div></div><div class="declaration--wrapper" id="remove-items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes every item from the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-items-by [:a :b :c] keyword?)<br>=&gt;<br>[]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-items-by<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [result x]<br>                   (if (-> x f)<br>                       (-> result)<br>                       (-> result (conj x))))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="remove-duplicates"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-duplicates</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes every duplicates from the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-duplicates [:a :b :c :a])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-duplicates-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-duplicates-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-duplicates<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x]<br>                   (if (-> result (contain/contains-item? x))<br>                       (-> result)<br>                       (-> result (conj x))))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="remove-first-occurence"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-first-occurence</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the first occurence of the given 'x' item from the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-first-occurence [:a :b :c :d :d :e] :d)<br>=&gt;<br>[:a :b :c :d :e]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-first-occurence-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-first-occurence-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-first-occurence<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [item-dex (dex/first-dex-of n x)]<br>               (if (number? item-dex)<br>                   (vec (concat (subvec n 0 item-dex)<br>                                (subvec n (inc item-dex)))))<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="keep-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only those items in the given 'n' vector that are present in the given 'xyz' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-items [:a :b :c :d] [:b :c])<br>=&gt;<br>[:b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-items<br>  [n xyz]<br>  (let [n   (mixed/to-vector n)<br>        xyz (mixed/to-vector xyz)]<br>       (letfn [(f0 [result x]<br>                   (if (-> xyz    (contain/contains-item? x))<br>                       (-> result (conj                   x))<br>                       (-> result)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="keep-items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only those items in the given 'n' vector that match the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-items-by [:a :b "c" "d"] keyword?)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-items-by<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [result x]<br>                   (if (-> x f)<br>                       (-> result (conj x))<br>                       (-> result)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="replace-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">replace-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces items (that are indentical to the given 'a' value) in the given 'n' vector with the given 'b' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-item [:a :b :c :d :c] :c :x)<br>=&gt;<br>[:a :b :x :d :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-item [:a :b :b :b] :b :x)<br>=&gt;<br>[:a :x :x :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="replace-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;replace-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn replace-item<br>  [n a b]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x]<br>                   (if (= x a)<br>                       (conj result b)<br>                       (conj result x)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="replace-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">replace-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the first item in the given 'n' vector with the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-first-item [:a :b :c] :x)<br>=&gt;<br>[:x :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-first-item [] :x)<br>=&gt;<br>[]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="replace-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;replace-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn replace-first-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (cond (-> n count (< 1)) (-> n)<br>             (-> n count (= 1)) (-> [x])<br>             (-> n count (> 1)) (vec (cons x (subvec n 1))))))</pre></div></div><div class="declaration--wrapper" id="replace-second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">replace-second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the second item in the given 'n' vector with the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-second-item [:a :b :c] :x)<br>=&gt;<br>[:a :x :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-second-item [:a] :x)<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="replace-second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;replace-second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn replace-second-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (cond (-> n count (< 2)) (-> n)<br>             (-> n count (= 2)) (-> [(first n) x])<br>             (-> n count (> 2)) (vec (concat [(first n) x] (subvec n 2))))))</pre></div></div><div class="declaration--wrapper" id="replace-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">replace-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the last item in the given 'n' vector with the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-last-item [:a :b :c] :x)<br>=&gt;<br>[:a :b :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-last-item [] :x)<br>=&gt;<br>[]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="replace-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;replace-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn replace-last-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (cond (-> n count (< 1)) (-> n)<br>             (-> n count (= 1)) (-> [x])<br>             (-> n count (> 1)) (conj (subvec n 0 (-> n count dec)) x))))</pre></div></div><div class="declaration--wrapper" id="replace-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">replace-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the nth item in the given 'n' vector with the given 'x' value.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-nth-item [:a :b :c] 1 :x)<br>=&gt;<br>[:a :x :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(replace-nth-item [:a :b :c :d] 999 :x)<br>=&gt;<br>[:a :b :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="replace-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;replace-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn replace-nth-item<br>  [n th x]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (vec (concat (subvec n 0 th)<br>                            [x]<br>                            (subvec n (inc th))))<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="first-result"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-result</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first item of the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-result [:a :b :c "d"] keyword?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-result [:a :b :c "d"] #(if (keyword? %) (name %)))<br>=&gt;<br>"a"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-result-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-result-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-result<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (if-let [result (-> n (nth dex) f)]<br>                         (-> result)<br>                         (-> dex inc recur))))))</pre></div></div><div class="declaration--wrapper" id="second-result"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">second-result</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the second item of the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(second-result [:a :b :c "d"] keyword?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(second-result [:a :b :c "d"] #(if (keyword? %) (name %)))<br>=&gt;<br>"b"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="second-result-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;second-result-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn second-result<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (if-let [result (-> n (nth dex) f)]<br>                         (if (-> 1 (= match-count))<br>                             (-> result)<br>                             (recur (inc dex)<br>                                    (inc match-count)))<br>                         (recur (inc dex) match-count))))))</pre></div></div><div class="declaration--wrapper" id="last-result"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">last-result</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the last item of the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-result [:a :b :c "d"] keyword?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(last-result [:a :b :c "d"] #(if (keyword? %) (name %)))<br>=&gt;<br>"c"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="last-result-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;last-result-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn last-result<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (loop [dex (-> n count dec)]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (if-let [result (-> n (nth dex) f)]<br>                         (-> result)<br>                         (-> dex dec recur))))))</pre></div></div><div class="declaration--wrapper" id="nth-result"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">nth-result</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the nth item of the given 'n' vector that matches the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-result [:a :b :c "d"] keyword? 1)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(nth-result [:a :b :c "d"] #(if (keyword? %) (name %)) 1)<br>=&gt;<br>"b"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="nth-result-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;nth-result-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn nth-result<br>  [n f th]<br>  (let [n  (mixed/to-vector n)<br>        f  (mixed/to-ifn f)<br>        th (mixed/to-integer th)]<br>       (loop [dex 0 match-count 0]<br>             (if (seqable/dex-in-bounds? n dex)<br>                 (if-let [result (-> n (nth dex) f)]<br>                         (if (-> th (= match-count))<br>                             (-> result)<br>                             (recur (inc dex)<br>                                    (inc match-count)))<br>                         (recur (inc dex) match-count))))))</pre></div></div><div class="declaration--wrapper" id="all-results"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">all-results</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns all items of the given 'n' vector that match the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-results [:a :b :c "d"] keyword?)<br>=&gt;<br>[true true true]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-results [:a :b :c "d"] #(if (keyword? %) (name %)))<br>=&gt;<br>["a" "b" "c"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="all-results-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;all-results-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn all-results<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [results x]<br>                   (if-let [result (f x)]<br>                           (-> results conj result)<br>                           (-> results)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="result-count"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">result-count</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns how many items of the given 'n' vector match the given 'f' predicate function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(result-count [:a :b "c"] keyword?)<br>=&gt;<br>2</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="result-count-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;result-count-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn result-count<br>  [n f]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (count (filter f n))))</pre></div></div><div class="declaration--wrapper" id="flat-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">flat-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Flattens the nested vectors within the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">convert-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">Default: return</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(flat-items [[:a :b :c] [:d :e :f [:g :h :i]]])<br>=&gt;<br>[:a :b :c :d :e :f :g :h :i]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(flat-items [[:a :b :c] [:d :e :f [:g :h :i]]] name)<br>=&gt;<br>["a" "b" "c" "d" "e" "f" "g" "h" "i"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="flat-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;flat-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn flat-items<br>  ([n]<br>   (flat-items n return))<br><br>  ([n convert-f]<br>   (let [n         (mixed/to-vector n)<br>         convert-f (mixed/to-ifn convert-f)]<br>        (letfn [(f0 [result x]<br>                    (vec (if (-> x vector?)<br>                             (-> result (concat (flat-items x convert-f)))<br>                             (-> result (conj   (convert-f  x))))))]<br>               (reduce f0 [] n)))))</pre></div></div><div class="declaration--wrapper" id="sum-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sum-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Sums the number type items in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sum-items [10 5])<br>=&gt;<br>15</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sum-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sum-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sum-items<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [sum x]<br>                   (if (-> x number?)<br>                       (-> sum (+ x))<br>                       (-> sum)))]<br>              (reduce f0 0 n))))</pre></div></div><div class="declaration--wrapper" id="sum-items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sum-items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Sums the derived number type values of items in the given 'n' vector.<br>- Values are derived by applying the given 'f' function on the item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sum-items-by [{:value 10} {:value 5}] :value)<br>=&gt;<br>15</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sum-items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sum-items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sum-items-by<br>  [n f]<br>  (let [n (mixed/to-vector n) <br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [sum x]<br>                   (let [v (f x)]<br>                        (if (-> v number?)<br>                            (+  sum v)<br>                            (-> sum))))]<br>              (reduce f0 0 n))))</pre></div></div><div class="declaration--wrapper" id="gap-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">gap-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Inserts the given 'delimiter' value between every two items in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">delimiter</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(gap-items [:a :b :c :d] :x)<br>=&gt;<br>[:a :x :b :x :c :x :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="gap-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;gap-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn gap-items<br>  [n delimiter]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result dex x]<br>                   (if (-> dex zero?)<br>                       [x]<br>                       (conj result delimiter x)))]<br>              (reduce-kv f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="prefix-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">prefix-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Inserts the given 'prefix' item before every item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">prefix</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(prefix-items [:a :b :c :d] :x)<br>=&gt;<br>[:x :a :x :b :x :c :x :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="prefix-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;prefix-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn prefix-items<br>  [n prefix]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x] (conj result prefix x))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="suffix-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">suffix-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Inserts the given 'suffix' item after every item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">suffix</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(suffix-items [:a :b :c :d] :x)<br>=&gt;<br>[:a :x :b :x :c :x :d :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="suffix-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;suffix-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn suffix-items<br>  [n suffix]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(f0 [result x] (conj result x suffix))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="repeat-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">repeat-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">count</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(repeat-item :a 5)<br>=&gt;<br>[:a :a :a :a :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="repeat-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;repeat-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn repeat-item<br>  [x count]<br>  (cond (-> count integer? not) (-> [])<br>        :repeat-item<br>        (vec (repeat count x))))</pre></div></div><div class="declaration--wrapper" id="reverse-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">reverse-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the given 'n' vector with its items in reversed order.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(reverse-items [:a :b :c])<br>=&gt;<br>[:c :b :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="reverse-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;reverse-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn reverse-items<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (-> n reverse vec)))</pre></div></div><div class="declaration--wrapper" id="abc-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">abc-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the given 'n' vector with its items in alphabetical order.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(abc-items [:b "b" :a "a" nil])<br>=&gt;<br>[nil "a" "b" :a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="abc-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;abc-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn abc-items<br>  [n]<br>  (let [n (mixed/to-vector n)]<br>       (letfn [(sort-item-f [result x] (cond (string?  x) (update result :string-items     conj x)<br>                                             (keyword? x) (update result :keyword-items    conj x)<br>                                             :return      (update result :unsortable-items conj x)))<br>               (sort-items-f [n] (reduce sort-item-f {} n))]<br>              (let [{:keys [string-items keyword-items unsortable-items]} (sort-items-f n)]<br>                   (vec (concat unsortable-items (sort string-items)<br>                                                 (sort keyword-items)))))))</pre></div></div><div class="declaration--wrapper" id="sort-items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sort-items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the given 'n' vector with its items ordered with the given comparator function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">comparator-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sort-items ["a" "c" "b"] fruits.string.api/abc?)<br>=&gt;<br>["a" "b" "c"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sort-items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sort-items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sort-items<br>  ([n]<br>   (-> n sort vec))<br><br>  ([n comparator-f]<br>   (let [n            (mixed/to-vector n)<br>         comparator-f (mixed/to-ifn comparator-f)]<br>        (letfn [(f0 [a b] (boolean (comparator-f a b)))]<br>               (vec (sort f0 n))))))</pre></div></div><div class="declaration--wrapper" id="items-sorted_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">items-sorted?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given vector's items are ordered with the given comparator function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">comparator-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(items-sorted? ["a" "c" "b"] fruits.string.api/abc?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(items-sorted? ["a" "b" "c"] fruits.string.api/abc?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="items-sorted_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;items-sorted_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn items-sorted?<br>  [n comparator-f]<br>  (let [n            (mixed/to-vector n)<br>        comparator-f (mixed/to-ifn comparator-f)]<br>       (letfn [(f0 [a b] (boolean (comparator-f a b)))]<br>              (= n (sort-items n f0)))))</pre></div></div><div class="declaration--wrapper" id="sort-items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sort-items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the given 'n' vector with its items ordered with the given comparator function<br>that compares not the items but their derived values by the 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">comparator-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sort-items-by [{:a 3} {:a 2} {:a 1}] :a)<br>=&gt;<br>[{:a 1} {:a 2} {:a 3}]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sort-items-by [[1 2] [2 2] [2 3]] &gt; first)<br>=&gt;<br>[[2 2] [2 3] [1 2]]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sort-items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sort-items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sort-items-by<br>  ([n f]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn f)]<br>        (vec (sort-by f n))))<br><br>  ([n comparator-f f]<br>   (let [n            (mixed/to-vector n)<br>         comparator-f (mixed/to-ifn f)<br>         f            (mixed/to-ifn f)]<br>        (letfn [(f0 [a b] (boolean (comparator-f a b)))]<br>               (vec (sort-by f f0 n))))))</pre></div></div><div class="declaration--wrapper" id="sort-items-by-dexes"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sort-items-by-dexes</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the given 'n' vector with its items ordered by the given index vector<br>that describes which items to keep and in what order.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">dexes</pre><pre class="text--xs color--muted">integers in vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sort-items-by-dexes [:a :b :c] [2 0 1])<br>=&gt;<br>[:c :a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sort-items-by-dexes [:a :b :c] [2 0])<br>=&gt;<br>[:c :a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sort-items-by-dexes-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sort-items-by-dexes-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sort-items-by-dexes<br>  [n dexes]<br>  (let [n     (mixed/to-vector n)<br>        dexes (mixed/to-vector dexes)<br>        dexes (map mixed/to-integer dexes)]<br>       (letfn [(f0 [result dex]<br>                   (if-let [item (get/nth-item n dex)]<br>                           (conj result item)<br>                           (->   result)))]<br>              (reduce f0 [] dexes))))</pre></div></div><div class="declaration--wrapper" id="sorted-dexes"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">sorted-dexes</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Takes two vectors and returns a new one that contains the positions of the second<br>  vector's items in the first vector.<br>- If an item of the second vector is not present in the first vector, it's position<br>  won't be in the return vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sorted-dexes [:a :b :c] [:c :a :b])<br>=&gt;<br>[2 0 1]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sorted-dexes [:a :b :c] [:c :a])<br>=&gt;<br>[2 0]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(sorted-dexes [:a :b :c] [:c :a :b :d])<br>=&gt;<br>[2 0 1]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">integers in vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="sorted-dexes-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;sorted-dexes-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn sorted-dexes<br>  [a b]<br>  (let [a (mixed/to-vector a)<br>        b (mixed/to-vector b)]<br>       (letfn [(f0 [dexes x]<br>                   (if-let [dex (dex/first-dex-of a x)]<br>                           (conj dexes dex)<br>                           (->   dexes)))]<br>              (reduce f0 [] b))))</pre></div></div><div class="declaration--wrapper" id="compared-items-sorted_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">compared-items-sorted?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Compares two vectors by comparing their items (at the same index) with the comparator function.<br>- When iterating over the two vectors if items at the same index are not match, it returns the output<br>  of the comparator function that takes that two items.<br>- If the elements in vectors 'a' and 'b' match in value and the number of elements is the same, it returns TRUE.<br>- If the number of elements in vector 'a' is not equal to the number of elements in vector 'b', the comparison is<br>  performed up to the lower number of elements (if the compared elements match if vector 'a' has the smaller number<br>  of elements it returns TRUE; otherwise, it returns FALSE).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">comparator-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? [0 1 3] [0 1 2] &lt;)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? [0 1 3] [0 1 4] &lt;)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? [0 1 3] [0 1 3] &lt;)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? [] [] &lt;)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? ["a" "b" "c"] ["d" "a"] fruits.string.api/abc?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(compared-items-sorted? ["a" "b" "c"] ["a" "b"] fruits.string.api/abc?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="compared-items-sorted_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;compared-items-sorted_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn compared-items-sorted?<br>  [a b comparator-f]<br>  (let [a            (mixed/to-vector a)<br>        b            (mixed/to-vector b) <br>        comparator-f (mixed/to-ifn comparator-f)<br>        max-count    (min (count a) (count b))]<br>       (letfn [(f0 [dex]<br>                   (let [x (get a dex)<br>                         y (get b dex)]<br>                        (if (= x y)<br>                            (if (= (inc dex) max-count)<br>                                (<= (count a) (count b))<br>                                (f0 (inc dex)))<br>                            (comparator-f x y))))]<br>              (case max-count 0 (-> true)<br>                                (f0 0)))))</pre></div></div><div class="declaration--wrapper" id="prev-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">prev-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the item that precedes the given 'x' item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(prev-item [:a :b :c :d] :b)<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(prev-item [:a :b :c :d] nil)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(prev-item [] :a)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="prev-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;prev-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn prev-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [item-first-dex (dex/first-dex-of n x)]<br>               (let [prev-item-dex (seqable/prev-dex n item-first-dex)]<br>                    (get/nth-item n prev-item-dex)))))</pre></div></div><div class="declaration--wrapper" id="next-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">next-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the item that follows the given 'x' item in the given 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(next-item [:a :b :c :d] :a)<br>=&gt;<br>:b</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(next-item [:a :b :c :d] nil)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(next-item [] :a)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="next-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;next-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn next-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [item-first-dex (dex/first-dex-of n x)]<br>               (let [next-item-dex (seqable/next-dex n item-first-dex)]<br>                    (get/nth-item n next-item-dex)))))</pre></div></div><div class="declaration--wrapper" id="toggle-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">toggle-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Toggles the presence of the given 'x' value in the 'n' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle-item [:a :b] :c)<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle-item [:a :b :c] :c)<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="toggle-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;toggle-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn toggle-item<br>  [n x]<br>  (if (contain/contains-item? n x)<br>      (remove/remove-item     n x)<br>      (add/conj-item          n x)))</pre></div></div><div class="declaration--wrapper" id="update-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the first item in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-first-item [:a :b :c] name)<br>=&gt;<br>["a" :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-first-item [1 2 3] + 10)<br>=&gt;<br>[11 2 3]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-first-item<br>  [n f & params]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (if (-> n empty?)<br>           (-> n)<br>           (apply update n 0 f params))))</pre></div></div><div class="declaration--wrapper" id="update-second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the second item in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-second-item [:a :b :c] name)<br>=&gt;<br>[:a "b" :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-second-item [1 2 3] + 10)<br>=&gt;<br>[1 12 3]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-second-item<br>  [n f & params]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (if (-> n count (< 2))<br>           (-> n)<br>           (apply update n 1 f params))))</pre></div></div><div class="declaration--wrapper" id="update-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the last item in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-last-item [:a :b :c] name)<br>=&gt;<br>[:a :b "c"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-last-item [1 2 3] + 10)<br>=&gt;<br>[1 2 13]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-last-item<br>  [n f & params]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (if (-> n empty?)<br>           (-> n)<br>           (apply update n (-> n count dec) f params))))</pre></div></div><div class="declaration--wrapper" id="update-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the nth item in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-nth-item [:a :b :c] 1 name)<br>=&gt;<br>[:a "b" :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-nth-item [1 2 3] 1 + 10)<br>=&gt;<br>[1 12 3]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-nth-item<br>  [n th f & params]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (apply update n th f params)<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="update-all-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-all-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all item in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-item [:a :b :c] name)<br>=&gt;<br>["a" "b" "c"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-item [1 2 3] + 10)<br>=&gt;<br>[11 12 13]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-all-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-all-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-all-item<br>  [n f & params]<br>  (let [n (mixed/to-vector n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [result x]<br>                   (conj result (apply f x params)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="update-first-item-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-first-item-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the first match of the given 'test-f' function in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-first-item-by ["a" :b :c :d] keyword? name)<br>=&gt;<br>["a" "b" :c :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-first-item-by [1 2 3 4] even? + 10)<br>=&gt;<br>[1 12 3 4]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-first-item-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-first-item-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-first-item-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (if-let [dex (dex/first-dex-by n test-f)]<br>               (apply update n dex f params)<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="update-second-item-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-second-item-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the second match of the given 'test-f' function in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-second-item-by ["a" :b :c :d] keyword? name)<br>=&gt;<br>["a" :b "c" :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-second-item-by [1 2 3 4] even? + 10)<br>=&gt;<br>[1 2 3 14]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-second-item-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-second-item-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-second-item-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (if-let [dex (dex/second-dex-by n test-f)]<br>               (apply update n dex f params)<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="update-last-item-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-last-item-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the last match of the given 'test-f' function in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-last-item-by [:a :b :c "d"] keyword? name)<br>=&gt;<br>[:a :b "c" "d"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-last-item-by [1 2 3 4] odd? + 10)<br>=&gt;<br>[1 2 13 4]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-last-item-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-last-item-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-last-item-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (if-let [dex (dex/last-dex-by n test-f)]<br>               (apply update n dex f params)<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="update-nth-item-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-nth-item-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the nth match of the given 'test-f' function in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-nth-item-by ["a" :b :c :d] keyword? 1 name)<br>=&gt;<br>["a" :b "c" :d]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-nth-item-by [1 2 3 4] even? 1 + 10)<br>=&gt;<br>[1 2 3 14]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-nth-item-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-nth-item-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-nth-item-by<br>  [n test-f th f & params]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        th     (mixed/to-integer th)<br>        f      (mixed/to-ifn f)]<br>       (if-let [dex (dex/nth-dex-by n test-f th)]<br>               (apply update n dex f params)<br>               (-> n))))</pre></div></div><div class="declaration--wrapper" id="update-items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all match of the given 'test-f' function in the given 'n' vector with the given 'f' function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-items-by [:a :b :c "d"] keyword? name)<br>=&gt;<br>["a" "b" "c" "d"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-items-by [1 2 3 4] even? + 10)<br>=&gt;<br>[1 12 1 14]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-items-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-vector n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (letfn [(f0 [result x]<br>                   (if (test-f x)<br>                       (conj result (apply f x params))<br>                       (conj result x)))]<br>              (reduce f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="upsert-first-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">upsert-first-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the first item (if any) in the given 'n' vector with the given 'x' value,<br>otherwise it inserts the given 'x' value as first item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-first-item [:a :b :c] :x)<br>=&gt;<br>[:x :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-first-item [] :x)<br>=&gt;<br>[:x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="upsert-first-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;upsert-first-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn upsert-first-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n empty? not)<br>           (replace/replace-first-item n x)<br>           (conj n x))))</pre></div></div><div class="declaration--wrapper" id="upsert-second-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">upsert-second-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the second item (if any) in the given 'n' vector with the given 'x' value,<br>otherwise it inserts the given 'x' value as second (or first) item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-second-item [:a :b :c] :x)<br>=&gt;<br>[:a :x :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-second-item [:a] :x)<br>=&gt;<br>[:a :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-second-item [] :x)<br>=&gt;<br>[:x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="upsert-second-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;upsert-second-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn upsert-second-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n count (>= 2))<br>           (replace/replace-second-item n x)<br>           (conj n x))))</pre></div></div><div class="declaration--wrapper" id="upsert-last-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">upsert-last-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the last item (if any) in the given 'n' vector with the given 'x' value,<br>otherwise it inserts the given 'x' value as last item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-last-item [:a :b :c] :x)<br>=&gt;<br>[:a :b :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-last-item [] :x)<br>=&gt;<br>[:x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="upsert-last-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;upsert-last-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn upsert-last-item<br>  [n x]<br>  (let [n (mixed/to-vector n)]<br>       (if (-> n empty? not)<br>           (replace/replace-last-item n x)<br>           (conj n x))))</pre></div></div><div class="declaration--wrapper" id="upsert-nth-item"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">upsert-nth-item</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Replaces the nth item (if any) in the given 'n' vector with the given 'x' value,<br>otherwise it inserts the given 'x' value as nth item.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">th</pre><pre class="text--xs color--muted">integer</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-nth-item [:a :b :c] 0 :x)<br>=&gt;<br>[:x :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(upsert-nth-item [:a :b :c] 5 :x)<br>=&gt;<br>[:a :b :c :x]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="upsert-nth-item-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;upsert-nth-item-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn upsert-nth-item<br>  [n th x]<br>  (let [n (mixed/to-vector n)]<br>       (if-let [th (seqable/normalize-dex n th {:adjust? false :mirror? true})]<br>               (replace/replace-nth-item n th x)<br>               (conj n x))))</pre></div></div><div class="declaration--wrapper" id="-_items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each item of the given 'n' vector.<br>- The 'f' function takes an item and optionally the corresponding index as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-dex? (boolean)(opt)<br>  If TRUE, provides the corresponding index also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;items [:a :b :c] name)<br>=&gt;<br>["a" "b" "c"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->items<br>  ([n f]<br>   (->items n f {}))<br><br>  ([n f {:keys [provide-dex?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [       dex x] (if provide-dex? (f dex x) (f x)))<br>                (f1 [result dex x] (conj result (f0 dex x)))]<br>               (reduce-kv f1 [] n)))))</pre></div></div><div class="declaration--wrapper" id="-_items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on items of the given 'n' vector that for the given 'test-f' returns TRUE.<br>- The 'f' function takes an item and optionally the corresponding index as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-dex? (boolean)(opt)<br>  If TRUE, provides the corresponding index also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;items-by [0 1 2] even? inc)<br>=&gt;<br>[1 1 3]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->items-by<br>  ([n test-f f]<br>   (->items-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-dex?]}]<br>   (let [n      (mixed/to-vector n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [       dex x] (if provide-dex? (f  dex x) (f x)))<br>                (f1 [       dex x] (if (test-f x) (f0 dex x) x))<br>                (f2 [result dex x] (conj result (f1 dex x)))]<br>               (reduce-kv f2 [] n)))))</pre></div></div><div class="declaration--wrapper" id="-__items"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>items</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each item of the given 'n' vector (recursivelly).<br>- The 'f' function takes an item and optionally the corresponding index or path as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-dex? (boolean)(opt)<br>  If TRUE, provides the corresponding index also to the given 'f' function.<br>  Default: false<br> :provide-path? (boolean)(opt)<br>  If TRUE, provides the corresponding path also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;items [:a :b :c [:d :e {:e :f}]] name)<br>=&gt;<br>["a" "b" "c" ["d" "e" {:e "f"}]]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__items-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__items-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>items<br>  ([n f]<br>   (->>items n f {}))<br><br>  ([n f {:keys [provide-dex? provide-path?]}]<br>   (let [n (mixed/to-vector n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [path x] (if provide-dex? (f (last path) x) (if provide-path? (f path x) (f x))))<br>                (f1 [path x] (cond (vector? x) (reduce-kv #(conj  %1    (f1 (conj path %2) %3)) [] x)<br>                                   (map?    x) (reduce-kv #(assoc %1 %2 (f1 (conj path %2) %3)) {} x)<br>                                   :return     (f0 path x)))]<br>               (f1 [] n)))))</pre></div></div><div class="declaration--wrapper" id="-__items-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>items-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on items of the given 'n' vector (recursivelly) that for the given 'test-f' returns TRUE.<br>- The 'f' function takes an item and optionally the corresponding index or path as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-dex? (boolean)(opt)<br>  If TRUE, provides the corresponding index also to the given 'f' function.<br>  Default: false<br> :provide-path? (boolean)(opt)<br>  If TRUE, provides the corresponding path also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;items [0 1 2 [3 4 5]] integer? inc)<br>=&gt;<br>[1 2 3 [4 5 6]]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__items-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__items-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>items-by<br>  ([n test-f f]<br>   (->>items-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-dex? provide-path?]}]<br>   (let [n      (mixed/to-vector n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [path x] (if provide-dex? (f (last path) x) (if provide-path? (f path x) (f x))))<br>                (f1 [path x] (if (test-f x) (f0 path x) x))<br>                (f2 [path x] (let [x (f1 path x)] <br>                                  (cond (vector? x) (reduce-kv #(conj  %1    (f2 (conj path %2) %3)) [] x)<br>                                        (map?    x) (reduce-kv #(assoc %1 %2 (f2 (conj path %2) %3)) {} x)<br>                                        :return x)))]<br>               (f2 [] n)))))</pre></div></div></div></div><div id="top-bar"><pre class="text--bold" id="top-bar--library-name">cljc-fruits</pre><pre class="color--muted" id="top-bar--library-version">1.0.8.4</pre><a href="https://github.com/bithandshake/cljc-fruits" id="top-bar--library-uri"><pre class="color--primary">github.com/bithandshake/cljc-fruits</pre></a></div><div id="bottom-bar"><a href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>
