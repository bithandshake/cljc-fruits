<!DOCTYPE html>
<html><html><head><style type="text/css">body{margin:0 0 0 560px;padding:60px 48px}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-container{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{font-size:13px;letter-spacing:.5px;line-height:18px;padding:3px 12px;white-space:inherit}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:24px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.text--l{font-size:14px;line-height:18px}.text--semi-bold{font-weight:500}.text--bold{font-weight:600}.color--basic{color:#303030}.color--primary{color:#0088cc}.color--secondary{color:#8800cc}.color--muted{color:#606060}.color--warning{color:#cc00aa}.collapsible-wrapper{display:flex;flex-direction:column}.collapsible-button{cursor:pointer;position:relative;user-select:none;width:fit-content}.collapsible-button:hover{color:#888}.collapsible-button::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;position:absolute;height:24px;right:-24px;top:0;width:24px}.collapsible-wrapper[data-expanded="true"] .collapsible-button::after{content:'▲'}.collapsible-wrapper .content-block--box{display:none}.collapsible-wrapper[data-expanded="true"] .content-block--box{display:block}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{font-size:12px;line-height:60px;padding:0 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{font-size:18px;line-height:60px;text-transform:uppercase}#top-bar--author-name{font-size:12px}#top-bar--library-version{font-size:12px;line-height:18px;margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{color:#aa55bb;font-size:12px;letter-spacing:.8px;line-height:42px;padding:0 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{font-size:18px;line-height:24px;margin-top:24px}#declarations{display:flex;flex-direction:column}.declaration--wrapper{padding-top:96px}.declaration--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.tutorial--wrapper{padding-top:96px}.tutorial--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.content-blocks{display:flex;flex-direction:column}.content-block--separator{height:12px}.content-block--label{display:flex;gap:4px;line-height:24px}.content-block--box{background-color:#fafafa;color:#333;line-height:16px;margin:0;padding:12px 8px}.content-block--preview-image{border:1px solid #dedede;display:block;max-height:480px;max-width:640px;min-height:48px;min-width:64px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.expanded==='true'){collapsible.dataset.expanded='false';}else{collapsible.dataset.expanded='true';}}</script></head><body><div id="primary-list"><div class="scroll-container"><div class="primary-list--container"><pre class="text--xs color--muted">Isomorphic namespaces</pre><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/alphabet/api.html"><pre class="button color--primary ">fruits.alphabet.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/atom/api.html"><pre class="button color--primary ">fruits.atom.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/audit/api.html"><pre class="button color--primary ">fruits.audit.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/base64/api.html"><pre class="button color--primary ">fruits.base64.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/bson/api.html"><pre class="button color--primary ">fruits.bson.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/css/api.html"><pre class="button color--primary ">fruits.css.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/eql/api.html"><pre class="button color--primary ">fruits.eql.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/format/api.html"><pre class="button color--primary ">fruits.format.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/gestures/api.html"><pre class="button color--primary ">fruits.gestures.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/hiccup/api.html"><pre class="button color--primary ">fruits.hiccup.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/href/api.html"><pre class="button color--primary ">fruits.href.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/html/api.html"><pre class="button color--primary ">fruits.html.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/http/api.html"><pre class="button color--primary ">fruits.http.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/integer/api.html"><pre class="button color--primary ">fruits.integer.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/json/api.html"><pre class="button color--primary ">fruits.json.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/keyword/api.html"><pre class="button color--primary ">fruits.keyword.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/layout/api.html"><pre class="button color--primary ">fruits.layout.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/logic/api.html"><pre class="button color--primary ">fruits.logic.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/loop/api.html"><pre class="button color--primary ">fruits.loop.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/lorem-ipsum/api.html"><pre class="button color--primary ">fruits.lorem-ipsum.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/map/api.html"><pre class="button color--primary button--active">fruits.map.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/math/api.html"><pre class="button color--primary ">fruits.math.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/mixed/api.html"><pre class="button color--primary ">fruits.mixed.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/namespace/api.html"><pre class="button color--primary ">fruits.namespace.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/noop/api.html"><pre class="button color--primary ">fruits.noop.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/normalize/api.html"><pre class="button color--primary ">fruits.normalize.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/pretty/api.html"><pre class="button color--primary ">fruits.pretty.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/print/api.html"><pre class="button color--primary ">fruits.print.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/random/api.html"><pre class="button color--primary ">fruits.random.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/reader/api.html"><pre class="button color--primary ">fruits.reader.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/regex/api.html"><pre class="button color--primary ">fruits.regex.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/seqable/api.html"><pre class="button color--primary ">fruits.seqable.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/string/api.html"><pre class="button color--primary ">fruits.string.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/svg/api.html"><pre class="button color--primary ">fruits.svg.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/syntax/api.html"><pre class="button color--primary ">fruits.syntax.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/uri/api.html"><pre class="button color--primary ">fruits.uri.api</pre></a><a href="https://bithandshake.github.io/cljc-fruits/cljc/fruits/vector/api.html"><pre class="button color--primary ">fruits.vector.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-container"><div class="secondary-list--container"><pre class="text--xs color--muted">Declarations</pre><a href="#-__keys"><pre class="button color--primary">->>keys</pre></a><a href="#-__keys-by"><pre class="button color--primary">->>keys-by</pre></a><a href="#-__kv"><pre class="button color--primary">->>kv</pre></a><a href="#-__values"><pre class="button color--primary">->>values</pre></a><a href="#-__values-by"><pre class="button color--primary">->>values-by</pre></a><a href="#-_keys"><pre class="button color--primary">->keys</pre></a><a href="#-_keys-by"><pre class="button color--primary">->keys-by</pre></a><a href="#-_kv"><pre class="button color--primary">->kv</pre></a><a href="#-_values"><pre class="button color--primary">->values</pre></a><a href="#-_values-by"><pre class="button color--primary">->values-by</pre></a><a href="#add-namespace"><pre class="button color--primary">add-namespace</pre></a><a href="#all-keys-match_"><pre class="button color--primary">all-keys-match?</pre></a><a href="#all-values-match_"><pre class="button color--primary">all-values-match?</pre></a><a href="#any-key-matches_"><pre class="button color--primary">any-key-matches?</pre></a><a href="#any-value-matches_"><pre class="button color--primary">any-value-matches?</pre></a><a href="#assoc-by"><pre class="button color--primary">assoc-by</pre></a><a href="#assoc-ns"><pre class="button color--primary">assoc-ns</pre></a><a href="#collapse"><pre class="button color--primary">collapse</pre></a><a href="#contains-all-key_"><pre class="button color--primary">contains-all-key?</pre></a><a href="#contains-any-key_"><pre class="button color--primary">contains-any-key?</pre></a><a href="#contains-key_"><pre class="button color--primary">contains-key?</pre></a><a href="#contains-value_"><pre class="button color--primary">contains-value?</pre></a><a href="#copy"><pre class="button color--primary">copy</pre></a><a href="#copy-in"><pre class="button color--primary">copy-in</pre></a><a href="#deep-merge"><pre class="button color--primary">deep-merge</pre></a><a href="#difference"><pre class="button color--primary">difference</pre></a><a href="#dissoc-by"><pre class="button color--primary">dissoc-by</pre></a><a href="#dissoc-in"><pre class="button color--primary">dissoc-in</pre></a><a href="#empty_"><pre class="button color--primary">empty?</pre></a><a href="#filter-values"><pre class="button color--primary">filter-values</pre></a><a href="#first-key"><pre class="button color--primary">first-key</pre></a><a href="#first-match-key"><pre class="button color--primary">first-match-key</pre></a><a href="#first-matching-key"><pre class="button color--primary">first-matching-key</pre></a><a href="#first-matching-value"><pre class="button color--primary">first-matching-value</pre></a><a href="#first-value"><pre class="button color--primary">first-value</pre></a><a href="#get-by"><pre class="button color--primary">get-by</pre></a><a href="#get-ns"><pre class="button color--primary">get-ns</pre></a><a href="#keep-key"><pre class="button color--primary">keep-key</pre></a><a href="#keep-keys"><pre class="button color--primary">keep-keys</pre></a><a href="#keep-keys-by"><pre class="button color--primary">keep-keys-by</pre></a><a href="#keep-value"><pre class="button color--primary">keep-value</pre></a><a href="#keep-values"><pre class="button color--primary">keep-values</pre></a><a href="#keep-values-by"><pre class="button color--primary">keep-values-by</pre></a><a href="#keys"><pre class="button color--primary">keys</pre></a><a href="#keys-by"><pre class="button color--primary">keys-by</pre></a><a href="#matches-pattern_"><pre class="button color--primary">matches-pattern?</pre></a><a href="#merge-some"><pre class="button color--primary">merge-some</pre></a><a href="#move"><pre class="button color--primary">move</pre></a><a href="#move-in"><pre class="button color--primary">move-in</pre></a><a href="#namespace"><pre class="button color--primary">namespace</pre></a><a href="#namespaced_"><pre class="button color--primary">namespaced?</pre></a><a href="#not-all-keys-match_"><pre class="button color--primary">not-all-keys-match?</pre></a><a href="#not-all-values-match_"><pre class="button color--primary">not-all-values-match?</pre></a><a href="#not-empty_"><pre class="button color--primary">not-empty?</pre></a><a href="#not-namespaced_"><pre class="button color--primary">not-namespaced?</pre></a><a href="#remove-key"><pre class="button color--primary">remove-key</pre></a><a href="#remove-keys"><pre class="button color--primary">remove-keys</pre></a><a href="#remove-keys-by"><pre class="button color--primary">remove-keys-by</pre></a><a href="#remove-namespace"><pre class="button color--primary">remove-namespace</pre></a><a href="#remove-value"><pre class="button color--primary">remove-value</pre></a><a href="#remove-values"><pre class="button color--primary">remove-values</pre></a><a href="#remove-values-by"><pre class="button color--primary">remove-values-by</pre></a><a href="#reversed-merge"><pre class="button color--primary">reversed-merge</pre></a><a href="#swap"><pre class="button color--primary">swap</pre></a><a href="#to-associative"><pre class="button color--primary">to-associative</pre></a><a href="#to-nil"><pre class="button color--primary">to-nil</pre></a><a href="#to-seqable"><pre class="button color--primary">to-seqable</pre></a><a href="#to-vector"><pre class="button color--primary">to-vector</pre></a><a href="#toggle"><pre class="button color--primary">toggle</pre></a><a href="#toggle-in"><pre class="button color--primary">toggle-in</pre></a><a href="#update-all-key"><pre class="button color--primary">update-all-key</pre></a><a href="#update-all-value"><pre class="button color--primary">update-all-value</pre></a><a href="#update-by"><pre class="button color--primary">update-by</pre></a><a href="#update-keys-by"><pre class="button color--primary">update-keys-by</pre></a><a href="#update-values-by"><pre class="button color--primary">update-values-by</pre></a><a href="#values"><pre class="button color--primary">values</pre></a><a href="#values-equal_"><pre class="button color--primary">values-equal?</pre></a></div></div></div><div id="namespace-header"><pre class="text--bold" id="namespace-header--title">fruits.map.api</pre><pre class="text--xs color--muted">Isomorphic namespace</pre></div><div id="tutorials--wrapper"><div id="tutorials"></div></div><div id="declarations--wrapper"><div id="declarations"><div class="declaration--wrapper" id="assoc-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">assoc-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Associates the given 'xyz' values to the given 'n' map at the given 'path' dynamic path.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(defn last-dex [%] (-&gt; % count dec))<br>(assoc-by {:a [{:b "B"} {:c "C"}]} [:a last-dex] :x "X")<br>=&gt;<br>{:a [{:b "B"} {:c "C" :x "X"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(assoc-by {:a [{:b "B"} {:c "C"}]} [:a #(-&gt; % count dec)] :x "X")<br>=&gt;<br>{:a [{:b "B"} {:c "C" :x "X"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="assoc-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;assoc-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn assoc-by<br>  [n path & xyz]<br>  (let [n    (convert/to-associative n)<br>        path (seqable/dynamic-path n path)]<br>       (apply assoc-in n path xyz)))</pre></div></div><div class="declaration--wrapper" id="empty_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">empty?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is an empty map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? {})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? {:a "A"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(empty? [:a])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="empty_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;empty_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn empty?<br>  [n]<br>  (and (-> n map?)<br>       (-> n clojure.core/empty?)))</pre></div></div><div class="declaration--wrapper" id="not-empty_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-empty?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is a nonempty map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? {})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? {:a "A"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-empty? [:a])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-empty_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-empty_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-empty?<br>  [n]<br>  (and (-> n map?)<br>       (-> n clojure.core/empty? not)))</pre></div></div><div class="declaration--wrapper" id="namespaced_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">namespaced?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is a namespaced map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespaced? {:a/b "A"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespaced? {:a "A"})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="namespaced_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;namespaced_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn namespaced?<br>  [n]<br>  (and (-> n map?)<br>       (-> n namespace some?)))</pre></div></div><div class="declaration--wrapper" id="not-namespaced_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-namespaced?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' value is a nonnamespaced map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-namespaced? {:a "A"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-namespaced? {:a/b "A"})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-namespaced_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-namespaced_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-namespaced?<br>  [n]<br>  (and (-> n map?)<br>       (-> n namespace nil?)))</pre></div></div><div class="declaration--wrapper" id="collapse"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">collapse</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Flattens the given 'n' nested map, converting its paths into dot-separated keys,<br>optionally keywordizing keys, and providing options to control which paths<br>are collapsed.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:separator (string)(opt)<br>  Default: "."<br> :inner-except-f (function)(opt)<br>  An optional control function that determines whether specific key-value<br>  pairs within nested maps should be excluded from the collapsing process.<br>  It is invoked for each key-value pair within nested maps during the inner iteration.<br>  If returns FALSE for a particular key-value pair, that pair will not be collapsed.<br> :keywordize? (boolean)(opt)<br>  Default: false<br> :outer-except-f (function)(opt)<br>  An optional control function that operates at the outer level of the map.<br>  Similar to 'inner-except-f', it determines whether specific key-value pairs<br>  at the outermost level of the map should be excluded from collapsing.}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(collapse {:a {:b "c"}})<br>=&gt;<br>{"a.b" "c"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(collapse {:a {:b "c"}} {:keywordize? true})<br>=&gt;<br>{:a.b "c"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(collapse {:a {:b {:c "d"} :q [{:r {:s "t"}}]}} {:keywordize? true})<br>=&gt;<br>{:a.b.c "d" :q [{:r.s "t"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">The ':c' key is an exception, and its value will not be collapsed to the outer map.<br>(defn my-inner-except-f [k v] (not= k :c))<br>(collapse {:a {:b {:c "d"}}} {:keywordize? true :except-f my-inner-except-f})<br>=&gt;<br>{:a.b {:c "d"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">The ':b' key is an exception, and its value's keys will not be collapsed to their outer map.<br>(defn my-outer-except-f [k v] (not= k :b))<br>(collapse {:a {:b {:c "d"}}} {:keywordize? true :except-f my-outer-except-f})<br>=&gt;<br>{:a.b {:c "d"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="collapse-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;collapse-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn collapse<br>  ([n]<br>   (collapse n {}))<br><br>  ([n {:keys [inner-except-f outer-except-f keywordize? separator] :or {separator "."}}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [<br>                (stringize-key-f [k] (if (keyword? k)<br>                                         (if-let [namespace (namespace k)]<br>                                                 (str namespace "/" (name k))<br>                                                 (name k))<br>                                         (str k)))<br><br>                (join-keys-f [a b] (if keywordize? (keyword (str (stringize-key-f a) separator (stringize-key-f b)))<br>                                                   (str          (stringize-key-f a) separator (stringize-key-f b))))<br><br>                (collapse-o? [ko vo] (and (map? vo)<br>                                          (or (not  outer-except-f)<br>                                              (not (outer-except-f ko vo)))))<br><br>                (collapse-i? [ki vi] (or (not  inner-except-f)<br>                                         (not (inner-except-f ki vi))))<br><br>                (map-f [ro ko vo] (if (collapse-o? ko vo)<br>                                      (letfn [<br>                                              (collapse-f [ri ki vi] (if (collapse-i? ki vi)<br>                                                                         (assoc    ri (join-keys-f ko ki) vi)<br>                                                                         (assoc-in ri [ko ki] vi)))]<br><br>                                             (reduce-kv collapse-f ro (walk-f vo)))<br><br>                                      (assoc ro ko (walk-f vo))))<br><br>                (vector-f [r x] (conj r (walk-f x)))<br><br>                (walk-f [n] (cond (vector? n) (reduce    vector-f [] n)<br>                                  (map?    n) (reduce-kv map-f    {} n)<br>                                  :return  n))]<br><br>               (walk-f n)))))</pre></div></div><div class="declaration--wrapper" id="difference"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">difference</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Computes the difference between the given 'a' and 'b' maps, returning key-value<br>pairs that are present in the 'a' map but not in the 'b' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(difference {:a "a" :b "b"} {:a "a"})<br>=&gt;<br>{:b "b"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="difference-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;difference-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn difference<br>  [a b]<br>  (let [a (mixed/to-map a)<br>        b (mixed/to-map b)]<br>       (-> a (clojure.data/diff b) first)))</pre></div></div><div class="declaration--wrapper" id="to-vector"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-vector</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' map into vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">convert-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">Default: (fn [k v] v)</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-vector {:a "A" b "B" :c "C"})<br>=&gt;<br>["A" "B" "C"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(defn my-convert-f [k v] [k v])<br>(to-vector {:a "A" b "B"} my-convert-f)<br>=&gt;<br>[[:a "A"] [:b "B"]]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-vector-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-vector-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-vector<br>  ([n]<br>   (to-vector n (fn [k v] v)))<br><br>  ([n convert-f]<br>   (let [n         (mixed/to-map n)<br>         convert-f (mixed/to-ifn convert-f)]<br>        (letfn [(f0 [result [k v]]<br>                    (conj result (convert-f k v)))]<br>               (reduce f0 [] n)))))</pre></div></div><div class="declaration--wrapper" id="to-nil"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-nil</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' map into NIL.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:if-empty? (boolean)(opt)<br>  Converts only if the given 'n' map is empty.<br>  Default: true}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-nil {})<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-nil {:a "A" :b "B" :c "C"})<br>=&gt;<br>{:a "A" :b "B" :c "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">nil or map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-nil-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-nil-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-nil<br>  ([n]<br>   (to-nil n {}))<br><br>  ([n {:keys [if-empty?] :or {if-empty? true}}]<br>   (let [n (mixed/to-map n)]<br>        (cond (-> n empty?)      (-> nil)<br>              (-> if-empty? not) (-> nil)<br>              :return n))))</pre></div></div><div class="declaration--wrapper" id="to-associative"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-associative</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' value into map, in case it does not implement the IAssociative protocol.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative {:a "A"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative [:a :b :c])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative nil)<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative "abc")<br>=&gt;<br>{0 "abc"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-associative 123)<br>=&gt;<br>{0 123}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map or associative *</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-associative-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-associative-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-associative<br>  [n]<br>  (cond (-> n associative?) (-> n)<br>        (-> n nil?)         (-> {})<br>        :else               (-> {0 n})))</pre></div></div><div class="declaration--wrapper" id="to-seqable"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">to-seqable</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Converts the given 'n' value into map, in case it does not implement the ISeqable protocol.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable {:a "A"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable [:a :b :c])<br>=&gt;<br>[:a :b :c]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable nil)<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable "abc")<br>=&gt;<br>"abc"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(to-seqable 123)<br>=&gt;<br>{0 123}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map or seqable *</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="to-seqable-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;to-seqable-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn to-seqable<br>  [n]<br>  (if (-> n seqable?)<br>      (-> n)<br>      (-> {0 n})))</pre></div></div><div class="declaration--wrapper" id="copy"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">copy</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates a specific value / specific values within the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(copy {:a "A" :b "B"} :a :x)<br>=&gt;<br>{:a "A" :b "B" :x "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(copy {:a "A" :b "B"} :a :x :b :y)<br>=&gt;<br>{:a "A" :b "B" :x "A" :y "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(copy {:a "A" :b "B"} :a :x :x :y)<br>=&gt;<br>{:a "A" :b "B" :x "A" :y "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="copy-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;copy-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn copy<br>  [n & ks]<br>  (let [n (mixed/to-map n)]<br>       (loop [n n ks (vec ks)]<br>             (if (-> ks count (< 2))<br>                 (-> n)<br>                 (recur (-> n  (assoc (second ks) (get n (first ks))))<br>                        (-> ks (subvec 2)))))))</pre></div></div><div class="declaration--wrapper" id="copy-in"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">copy-in</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Duplicates a specific nested value within the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">from</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(copy-in {:a {:b "B"}} [:a :b] [:x :y])<br>=&gt;<br>{:a {:b "B"} :x {:y "B"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="copy-in-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;copy-in-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn copy-in<br>  [n from to]<br>  (let [n    (mixed/to-map n)<br>        from (mixed/to-vector from)<br>        to   (mixed/to-vector to)]<br>       (assoc-in n to (get-in n from))))</pre></div></div><div class="declaration--wrapper" id="dissoc-in"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">dissoc-in</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">https://github.com/day8/re-frame/blob/master/src/re_frame/utils.cljc</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Dissociates a specific value from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(dissoc-in {:a {:b "B"}} [:a :b])<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="dissoc-in-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;dissoc-in-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn dissoc-in<br>  [n [k & ks :as path]]<br>  (let [n (mixed/to-map n)]<br>       (if ks (if-let [next-n (get n k)]<br>                      (let [new-n (dissoc-in next-n ks)]<br>                           (if (seq new-n)<br>                               (assoc n k new-n)<br>                               (dissoc n k)))<br>                      (-> n))<br>              (dissoc n k))))</pre></div></div><div class="declaration--wrapper" id="dissoc-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">dissoc-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Dissociates a specific value from the given 'n' map at the given 'path' dynamic path.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(defn last-dex [%] (-&gt; % count dec))<br>(dissoc-by {:a [{:b "B"} {:c "C"}]} [:a last-dex])<br>=&gt;<br>{:a [{:b "B"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(dissoc-by {:a [{:b "B"} {:c "C"}]} [:a #(-&gt; % count dec))])<br>=&gt;<br>{:a [{:b "B"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="dissoc-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;dissoc-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn dissoc-by<br>  [n path]<br>  (let [n    (mixed/to-map n)<br>        path (seqable/dynamic-path n path)]<br>       (dissoc-in n path)))</pre></div></div><div class="declaration--wrapper" id="filter-values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">filter-values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">filter-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(filter-values {:a 0 :b 1 :c 2} even?)<br>=&gt;<br>{:a 0 :c 2}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="filter-values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;filter-values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn filter-values<br>  [n filter-f]<br>  (let [n        (mixed/to-map n)<br>        filter-f (mixed/to-ifn filter-f)]<br>       (letfn [(f0 [%1 %2 %3] (if (-> %3 filter-f) (assoc %1 %2 %3) %1))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="keys"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keys</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the keys of the given 'n' map in a vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keys {:a {:c "C"} :b "B"})<br>=&gt;<br>[:a :b]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keys-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keys-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keys<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (-> n clojure.core/keys vec)))</pre></div></div><div class="declaration--wrapper" id="keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the keys of the given 'n' map for which the given 'f' function returns TRUE.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keys-by {:a "A" :b :b :c :c} string?)<br>=&gt;<br>[:a]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keys-by<br>  [n get-f]<br>  (let [n     (mixed/to-map n)<br>        get-f (mixed/to-ifn get-f)]<br>       (letfn [(f0 [%1 %2 %3] (if (get-f %3) (conj %1 %2) %1))]<br>              (reduce-kv f0 [] n))))</pre></div></div><div class="declaration--wrapper" id="first-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Clojure maps are unordered data structures.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first key of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-key {:a {:c "C"} :b "B"})<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-key<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (-> n clojure.core/keys first)))</pre></div></div><div class="declaration--wrapper" id="contains-key_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-key?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' map contains the given 'k' key.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-key? {:a {:b "B"}} :a)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-key? {:a {:b "B"}} :b)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-key_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-key_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-key?<br>  [n k]<br>  (let [n (mixed/to-map n)]<br>       (contains? n k)))</pre></div></div><div class="declaration--wrapper" id="contains-any-key_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-any-key?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' map contains any value associated to any key from the given 'ks' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">* in vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-any-key? {:a {:b "B"} :c "C"} [:a])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-any-key? {:a {:b "B"} :c "C"} [:a :b :c :d])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-any-key? {:a {:b "B"}} [:b :c :d])<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-any-key_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-any-key_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-any-key?<br>  [n ks]<br>  (let [n  (mixed/to-map n)<br>        ks (mixed/to-vector ks)]<br>       (letfn [(f0 [%] (contains? n %))]<br>              (boolean (some f0 ks)))))</pre></div></div><div class="declaration--wrapper" id="contains-all-key_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-all-key?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'n' map contains the values associated to all keys of the given 'ks' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">* in vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-all-key? {:a "A" :b "B"} [:a :b])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-all-key_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-all-key_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-all-key?<br>  [n ks]<br>  (let [n  (mixed/to-map n)<br>        ks (mixed/to-vector ks)]<br>       (letfn [(f0 [%] (contains? n %))]<br>              (every? ks f0))))</pre></div></div><div class="declaration--wrapper" id="get-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">get-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a specific value from the given 'n' map at the given 'path' dynamic path.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(defn last-dex [%] (-&gt; % count dec))<br>(get-by {:a [{:b "B"} {:c "C"}]} [:a last-dex])<br>=&gt;<br>{:c "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(get-by {:a [{:b "B"} {:c "C"}]} [:a #(-&gt; % count dec)])<br>=&gt;<br>{:c "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="get-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;get-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn get-by<br>  [n path]<br>  (let [n    (mixed/to-map n)<br>        path (seqable/dynamic-path n path)]<br>       (get-in n path)))</pre></div></div><div class="declaration--wrapper" id="any-key-matches_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">any-key-matches?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function returns TRUE for any key of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-key-matches? {:a "A" "b" "B"} string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-key-matches? {:a "A" :b "B"} string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="any-key-matches_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;any-key-matches_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn any-key-matches?<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (-> % first f))]<br>              (boolean (some f0 n)))))</pre></div></div><div class="declaration--wrapper" id="any-value-matches_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">any-value-matches?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function returns TRUE for any value of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-value-matches? {:a :A :b "B"} string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(any-value-matches? {:a "A" :b "B"} keyword?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="any-value-matches_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;any-value-matches_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn any-value-matches?<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (-> % second f))]<br>              (boolean (some f0 n)))))</pre></div></div><div class="declaration--wrapper" id="all-keys-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">all-keys-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function returns TRUE for all keys of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-keys-match? {:a "A" :b "B"} keyword?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-keys-match? {:a "A" "b" "B"} keyword?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="all-keys-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;all-keys-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn all-keys-match?<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (-> % first f))]<br>              (every? f0 n))))</pre></div></div><div class="declaration--wrapper" id="all-values-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">all-values-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function returns TRUE for all values of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-values-match? {:a "A" :b "B"} string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(all-values-match? {:a :A :b "B"} string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="all-values-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;all-values-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn all-values-match?<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (-> % second f))]<br>              (every? f0 n))))</pre></div></div><div class="declaration--wrapper" id="not-all-keys-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-all-keys-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function doesn't return TRUE for all keys of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-keys-match? {:a "A" "b" "B"} keyword?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-keys-match? {:a "A" :b "B"} keyword?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-all-keys-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-all-keys-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-all-keys-match?<br>  [n f]<br>  (-> (all-keys-match? n f) not))</pre></div></div><div class="declaration--wrapper" id="not-all-values-match_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">not-all-values-match?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if the given 'f' function doesn't return TRUE for all values of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-values-match? {:a "A" :b :B} string?)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(not-all-values-match? {:a "A" :b "B"} string?)<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="not-all-values-match_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;not-all-values-match_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn not-all-values-match?<br>  [n f]<br>  (-> (all-values-match? n f) not))</pre></div></div><div class="declaration--wrapper" id="first-match-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-match-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Clojure maps are unordered data structures.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first key of the given 'n' map for which the given 'f' function returns TRUE when applied on the corresponding value of the key.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-match-key {:a "A" :b "B"} string?)<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-match-key {:a "A" :b "B"} keyword?)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-match-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-match-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-match-key<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (if (-> % second f)<br>                           (-> % first)))]<br>              (some f0 n))))</pre></div></div><div class="declaration--wrapper" id="first-matching-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-matching-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Clojure maps are unordered data structures.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first key of the given 'n' map for which the given 'f' function returns TRUE when applied on all keys of the 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-matching-key {:a "A" "b" "B"} string?)<br>=&gt;<br>"b"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-matching-key {:a "A" :b "B"} string?)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-matching-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-matching-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-matching-key<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (if (-> % first f)<br>                           (-> % first)))]<br>              (some f0 n))))</pre></div></div><div class="declaration--wrapper" id="first-matching-value"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-matching-value</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Clojure maps are unordered data structures.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the first value of the given 'n' map for which the given 'f' function returns TRUE when applied to all values of the 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-matching-value {:a :A :b "B"} string?)<br>=&gt;<br>"B"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-matching-value {:a {:id "apple"} :b {:id "banana"}} #(= "apple" (:id %)))<br>=&gt;<br>{:id "apple"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-matching-value {:a "A" :b "B"} keyword?)<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-matching-value-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-matching-value-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-matching-value<br>  [n f]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [%] (if (-> % second f)<br>                           (-> % second)))]<br>              (some f0 n))))</pre></div></div><div class="declaration--wrapper" id="matches-pattern_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">matches-pattern?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns TRUE if all key-value pairs in the 'pattern' map are present in the 'n' map and, optionally, checks for strict matching.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">pattern</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:strict-matching? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(matches-pattern? {:a "A" :b "B"} {:a "A"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(matches-pattern? {:a "A" :b "B"} {:a "A" :c "C"})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(matches-pattern? {:a "A" :b "B"} {:a "A"} {:strict-matching? true})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(matches-pattern? {:a "A" :b "B"} {:a "A" :b "B"} {:strict-matching? true})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="matches-pattern_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;matches-pattern_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn matches-pattern?<br>  ([n pattern]<br>   (matches-pattern? n pattern {}))<br><br>  ([n pattern {:keys [strict-matching?]}]<br>   (let [difference (compare/difference n pattern)]<br>        (or <br>            (and (not strict-matching?)<br>                 (= (count n)<br>                    (+ (count difference)<br>                       (count pattern))))<br>            (and (boolean strict-matching?)<br>                 (= (count n)<br>                    (count pattern))<br>                 (empty? difference))))))</pre></div></div><div class="declaration--wrapper" id="deep-merge"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">deep-merge</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Merges the given nested maps.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of maps</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(deep-merge {:a {:b "a/b"}} {:a {:c "a/c"}})<br>=&gt;<br>{:a {:b "a/b" :c "a/c"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="deep-merge-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;deep-merge-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn deep-merge<br>  [n & xyz]<br>  (let [n   (mixed/to-map n)<br>        xyz (map mixed/to-map xyz)]<br>       (letfn [(f0 [result x]<br>                   (if (and (map? result)<br>                            (map? x))<br>                       (merge-with f0 result x)<br>                       (-> x)))]<br>              (if (some identity xyz)<br>                  (reduce f0 n xyz)<br>                  (-> n)))))</pre></div></div><div class="declaration--wrapper" id="reversed-merge"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">reversed-merge</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Merges the given maps in a reversed order.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of maps</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(reversed-merge {:a "A"} {:a "B"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(reversed-merge {:a "A"} {:a "B"} {:a "C"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="reversed-merge-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;reversed-merge-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn reversed-merge<br>  [& xyz]<br>  (let [xyz (map mixed/to-map xyz)]<br>       (apply merge (reverse xyz))))</pre></div></div><div class="declaration--wrapper" id="merge-some"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">merge-some</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Merges values of the given maps that are not NIL.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">xyz</pre><pre class="text--xs color--muted">list of maps</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(merge-some {:a "A"} {:a nil})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(merge-some {:a "A"} {:a nil} {:a "C"})<br>=&gt;<br>{:a "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="merge-some-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;merge-some-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn merge-some<br>  [& xyz]<br>  (let [xyz (map mixed/to-map xyz)]<br>       (letfn [(f0 [result x]   (reduce-kv f1 result x))<br>               (f1 [result k v] (if (-> v some?)<br>                                    (-> result (assoc k v))<br>                                    (-> result)))]<br>              (reduce f0 {} xyz))))</pre></div></div><div class="declaration--wrapper" id="move"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves a specific value / specific values within the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move {:a "A" :b "B"} :a :x)<br>=&gt;<br>{:x "A" :b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move {:a "A" :b "B"} :a :x :b :y)<br>=&gt;<br>{:x "A" :y "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move {:a "A" :b "B"} :a :x :x :y)<br>=&gt;<br>{:y "A" :b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move<br>  [n & ks]<br>  (let [n (mixed/to-map n)]<br>       (loop [n n ks (vec ks)]<br>             (if (-> ks count (< 2))<br>                 (-> n)<br>                 (recur (-> n  (assoc (second ks) (get n (first ks))) (dissoc (first ks)))<br>                        (-> ks (subvec 2)))))))</pre></div></div><div class="declaration--wrapper" id="move-in"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">move-in</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Moves a specific nested value within the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">from</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">to</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(move-in {:a {:b "B"}} [:a :b] [:x :y])<br>=&gt;<br>{:x {:y "B"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="move-in-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;move-in-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn move-in<br>  [n from to]<br>  (let [n    (mixed/to-map n)<br>        from (mixed/to-vector from)<br>        to   (mixed/to-vector to)]<br>       (-> n (dissoc/dissoc-in from)<br>             (assoc-in to (get-in n from)))))</pre></div></div><div class="declaration--wrapper" id="namespace"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">namespace</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns the namespace of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespace {:a "A"})<br>=&gt;<br>nil</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespace {:a/b "A"})<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespace {:a   "A"<br>            :b   "B"<br>            :c/d "C"<br>            :e/f "E"})<br>=&gt;<br>:c</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(namespace {"a/b" "A"})<br>=&gt;<br>:a</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">keyword</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="namespace-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;namespace-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn namespace<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (letfn [(f0 [k]<br>                   (cond (string? k)<br>                         (if-let [ns (-> k keyword clojure.core/namespace)]<br>                                 (keyword ns))<br>                         (keyword? k)<br>                         (if-let [ns (-> k clojure.core/namespace)]<br>                                 (keyword ns))))]<br>              (some f0 (keys n)))))</pre></div></div><div class="declaration--wrapper" id="add-namespace"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">add-namespace</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Adds a specific namespace to the keys of the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ns</pre><pre class="text--xs color--muted">keyword</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(add-namespace {:a "A"} :b)<br>=&gt;<br>{:a/b "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(add-namespace {"a" "A"} :b)<br>=&gt;<br>{"a/b" "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="add-namespace-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;add-namespace-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn add-namespace<br>  [n ns]<br>  (let [n  (mixed/to-map n)<br>        ns (mixed/to-keyword ns)]<br>       (letfn [(f0 [n k v]<br>                   (cond (string?  k) (assoc n (str     (name ns) "/"   k)  v)<br>                         (keyword? k) (assoc n (keyword (name ns) (name k)) v)<br>                         :return n))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="remove-namespace"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-namespace</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes the namespace of the keys in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-namespace {:a/b "A"})<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-namespace {"a/b" "A"})<br>=&gt;<br>{"a" "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-namespace-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-namespace-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-namespace<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (letfn [(f0 [n k v]<br>                   (cond (string?  k) (assoc n (-> k keyword name)         v)<br>                         (keyword? k) (assoc n (-> k         name keyword) v)<br>                         :return n))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="assoc-ns"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">assoc-ns</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Important</pre></div><pre class="text--m color--warning">This function is incomplete and may not behave as expected.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Associates the given key-value pair to given 'n' map adding the namespace of the map to the new key.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">keyword</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(assoc-ns {:fruit/apple "red"} :banana "yellow")<br>=&gt;<br>{:fruit/apple "red" :fruit/banana "yellow"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="assoc-ns-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;assoc-ns-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn assoc-ns<br>  [n k v])</pre></div></div><div class="declaration--wrapper" id="get-ns"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">get-ns</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Returns a specific value from the given 'n' map using the given key as it had the same namespace as the map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">keyword</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(get-ns {:fruit/apple "red"} :apple)<br>=&gt;<br>"red"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="get-ns-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;get-ns-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn get-ns<br>  [n k]<br>  (let [n (mixed/to-map n)<br>        k (mixed/to-keyword k)]<br>       (if-let [namespace (namespace n)]<br>               (let [k (keyword (name namespace) (name k))]<br>                    (get n k)))))</pre></div></div><div class="declaration--wrapper" id="remove-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes a specific key (optionally recursively) from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-key {:a "A" :b "B"} :a)<br>=&gt;<br>{:b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-key<br>  ([n k]<br>   (remove-key n k {}))<br><br>  ([n k {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [(f0 [result ki v] (cond (-> ki (= k))   (-> result)<br>                                        (-> recur? not) (-> result (assoc ki v))<br>                                        (-> v map?)     (-> result (assoc ki (remove-key v k options)))<br>                                        :else           (-> result (assoc ki v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="remove-keys"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-keys</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes specific keys (optionally recursively) from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-keys {:a "A" :b "B" :c "C"} [:a :c])<br>=&gt;<br>{:b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-keys-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-keys-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-keys<br>  ([n ks]<br>   (remove-keys n ks {}))<br><br>  ([n ks {:keys [recur?] :as options}]<br>   (let [n  (mixed/to-map n)<br>         ks (mixed/to-vector ks)]<br>        (letfn [(f0 [k] (some (fn [%] (= k %)) ks))<br>                (f1 [result k v] (cond (-> k f0)       (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (remove-keys v ks options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="remove-keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes keys (optionally recursively) that match the given 'f' function from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-keys-by {0 "A" 1 "B" 2 "C"} even?)<br>=&gt;<br>{1 "1"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-keys-by<br>  ([n f]<br>   (remove-keys-by n f {}))<br><br>  ([n f {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [(f0 [result k v] (cond (-> k f)        (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (remove-keys-by v f options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="remove-value"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-value</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes a specific value (optionally recursively) from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-value {:a "A" :b "B"} "A")<br>=&gt;<br>{:b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-value-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-value-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-value<br>  ([n v]<br>   (remove-value n v {}))<br><br>  ([n v {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [(f0 [result k vi] (cond (-> vi (= v))   (-> result)<br>                                        (-> recur? not) (-> result (assoc k vi))<br>                                        (-> vi map?)    (-> result (assoc k (remove-value vi v options)))<br>                                        :else           (-> result (assoc k vi))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="remove-values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes specific values (optionally recursively) from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">vs</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-values {:a "A" :b "B" :c "C"} ["A" "C"])<br>=&gt;<br>{:b "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-values<br>  ([n vs]<br>   (remove-values n vs {}))<br><br>  ([n vs {:keys [recur?] :as options}]<br>   (let [n  (mixed/to-map n)<br>         vs (mixed/to-vector vs)]<br>        (letfn [(f0 [v] (some (fn [%] (= v %)) vs))<br>                (f1 [result k v] (cond (-> v f0)       (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (remove-values v vs options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="remove-values-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">remove-values-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Removes values (optionally recursively) that match the given 'f' function from the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(remove-values-by {:a 0 :b 1 :c 2} even?)<br>=&gt;<br>{:b 1}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="remove-values-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;remove-values-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn remove-values-by<br>  ([n f]<br>   (remove-values-by n f {}))<br><br>  ([n f {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [result k v] (cond (-> v f)        (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (remove-values-by v f options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only a specific key (optionally recursively) in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-key {:a "A" :b "B"} :a)<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-key<br>  ([n k]<br>   (keep-key n k {}))<br><br>  ([n k {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [(f0 [result ki v] (cond (-> ki (not= k)) (-> result)<br>                                        (-> recur? not)  (-> result (assoc ki v))<br>                                        (-> v map?)      (-> result (assoc ki (keep-key v k options)))<br>                                        :else            (-> result (assoc ki v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-keys"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-keys</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only the given keys (optionally recursively) in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">ks</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-keys {:a "A" :b "B" :c "C"} [:a :c])<br>=&gt;<br>{:a "A" :c "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-keys-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-keys-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-keys<br>  ([n ks]<br>   (keep-keys n ks {}))<br><br>  ([n ks {:keys [recur?] :as options}]<br>   (let [n  (mixed/to-map n)<br>         ks (mixed/to-vector ks)]<br>        (letfn [(f0 [k] (some (fn [%] (not= k %)) ks))<br>                (f1 [result k v] (cond (-> k f0)       (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (keep-keys v ks options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only the keys (optionally recursively) that match the given 'f' function in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-keys-by {0 "0" 1 "1" 2 "2"} even?)<br>=&gt;<br>{0 "0" 2 "2"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-keys-by<br>  ([n f]<br>   (keep-keys-by n f {}))<br><br>  ([n f {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [result k v] (cond (-> k f not)    (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (keep-keys-by v f options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-value"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-value</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only a specific value (optionally recursively) in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-value {:a "A" :b "B"} "A")<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-value-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-value-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-value<br>  ([n v]<br>   (keep-value n v {}))<br><br>  ([n v {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)]<br>        (letfn [(f0 [result k vi] (cond (-> vi (not= v)) (-> result)<br>                                        (-> recur? not)  (-> result (assoc k vi))<br>                                        (-> vi map?)     (-> result (assoc k (keep-value vi v options)))<br>                                        :else            (-> result (assoc k vi))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only the given values (optionally recursively) in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">vs</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-values {:a "A" :b "B" :c "C"} ["A" "C"])<br>=&gt;<br>{:a "A" :c "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-values<br>  ([n vs]<br>   (keep-values n vs {}))<br><br>  ([n vs {:keys [recur?] :as options}]<br>   (let [n  (mixed/to-map n)<br>         vs (mixed/to-vector vs)]<br>        (letfn [(f0 [v] (some (fn [%] (not= v %)) vs))<br>                (f1 [result k v] (cond (-> v f0)       (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (keep-values v vs options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="keep-values-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">keep-values-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Keeps only the values (optionally recursively) that match the given 'f' function in the given 'n' map.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:recur? (boolean)(opt)<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(keep-values-by {:a 0 :b 1 :c 2} even?)<br>=&gt;<br>{:a 0 :c 2}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="keep-values-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;keep-values-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn keep-values-by<br>  ([n f]<br>   (keep-values-by n f {}))<br><br>  ([n f {:keys [recur?] :as options}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [result k v] (cond (-> v f not)    (-> result)<br>                                       (-> recur? not) (-> result (assoc k v))<br>                                       (-> v map?)     (-> result (assoc k (keep-values-by v f options)))<br>                                       :else           (-> result (assoc k v))))]<br>               (reduce-kv f0 {} n)))))</pre></div></div><div class="declaration--wrapper" id="swap"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">swap</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Swaps the keys and values in the given 'n' map.<br>Returns a new map with the values as keys and the keys as values.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(swap {:a "A" :b "B"})<br>=&gt;<br>{"A" :a "B" :b}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="swap-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;swap-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn swap<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (zipmap (vals n)<br>               (keys n))))</pre></div></div><div class="declaration--wrapper" id="toggle"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">toggle</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Associates a key-value pair to the given 'n' map if the key is not present,<br>or removes it if the key is already present.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle {} :a "A")<br>=&gt;<br>{:a "A"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle {:a "A"} :a "A")<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle {:a "B"} :a "A")<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="toggle-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;toggle-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn toggle<br>  [n k v]<br>  (let [n (mixed/to-map n)]<br>       (if-let [_ (get n k)]<br>               (dissoc n k)<br>               (assoc  n k v))))</pre></div></div><div class="declaration--wrapper" id="toggle-in"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">toggle-in</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Associates a nested key-value pair to the given 'n' map if the key is not present,<br>or removes it if the key is already present.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle-in {} [:a :b] "B")<br>=&gt;<br>{:a {:b "B"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle-in {:a "A"} [:a :b] "B")<br>=&gt;<br>{:a {:b "B"}}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(toggle-in {:a {:b "B"}} [:a :B] "B")<br>=&gt;<br>{}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="toggle-in-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;toggle-in-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn toggle-in<br>  [n path v]<br>  (let [n    (mixed/to-map n)<br>        path (mixed/to-vector path)]<br>       (if (get-in           n path)<br>           (dissoc/dissoc-in n path)<br>           (assoc-in         n path v))))</pre></div></div><div class="declaration--wrapper" id="update-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates the value in the given 'n' map at the given 'path' dynamic path.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(defn last-dex [%] (-&gt; % count dec))<br>(update-by {:a [{:b "B"} {:c "C"}]} [:a last-dex] assoc :x "X")<br>=&gt;<br>{:a [{:b "B"} {:c "C" :x "X"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-by {:a [{:b "B"} {:c "C"}]} [:a #(-&gt; % count dec)] assoc :x "X")<br>=&gt;<br>{:a [{:b "B"} {:c "C" :x "X"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-by<br>  [n path f & params]<br>  (let [n    (mixed/to-map n)<br>        f    (mixed/to-ifn f)<br>        path (seqable/dynamic-path n path)]<br>       (apply update-in n path f params)))</pre></div></div><div class="declaration--wrapper" id="update-all-key"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-all-key</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all key in the given 'n' map with the given 'f' function and passes the given parameters to the applied function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-key {:a "A" :b "B" :c "C"} name)<br>=&gt;<br>{"a" "A" "b" "B" "c" "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-key {0 "A" 1 "B" 2 "C"} + 10)<br>=&gt;<br>{10 "A" 11 "B" 12 "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-all-key-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-all-key-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-all-key<br>  [n f & params]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [result k v]<br>                   (assoc result (apply f k params) v))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="update-all-value"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-all-value</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all value in the given 'n' map with the given 'f' function and passes the given parameters to the applied function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-value {:a "A" :b "B" :c "C"} keyword)<br>=&gt;<br>{:a :A :b :B :c :C}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-all-value {:a 0 :b 1 :c 2} + 10)<br>=&gt;<br>{:a 10 :b 11 :c 12}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-all-value-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-all-value-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-all-value<br>  [n f & params]<br>  (let [n (mixed/to-map n)<br>        f (mixed/to-ifn f)]<br>       (letfn [(f0 [result k v]<br>                   (assoc result k (apply f v params)))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="update-keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all key (that the given 'test-f' function returns TRUE for) in the given 'n' map,<br>with the given 'f' function and passes the given parameters to the applied function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-keys-by {0 "A" 1 "B" 2 "C"} even? + 10)<br>=&gt;<br>{10 "A" 1 "B" 12 "C"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-keys-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-map n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (letfn [(f0 [result k v]<br>                   (if (test-f k)<br>                       (assoc result (apply f k params) v)<br>                       (assoc result k v)))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="update-values-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">update-values-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">Updates all value (that the given 'test-f' function returns TRUE for) in the given 'n' map,<br>with the given 'f' function and passes the given parameters to the applied function.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">params</pre><pre class="text--xs color--muted">list of *</pre><pre class="text--xs color--muted">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(update-values-by {:a 0 :b 1 :c 2} even? + 10)<br>=&gt;<br>{:a 10 :b 1 :c 12}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="update-values-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;update-values-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn update-values-by<br>  [n test-f f & params]<br>  (let [n      (mixed/to-map n)<br>        test-f (mixed/to-ifn test-f)<br>        f      (mixed/to-ifn f)]<br>       (letfn [(f0 [result k v]<br>                   (if (test-f v)<br>                       (assoc result k (apply f v params))<br>                       (assoc result k v)))]<br>              (reduce-kv f0 {} n))))</pre></div></div><div class="declaration--wrapper" id="values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(values {:a {:b "B"} :c "C"})<br>=&gt;<br>[{:b "B"} "C"]</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn values<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (-> n vals vec)))</pre></div></div><div class="declaration--wrapper" id="first-value"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">first-value</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Clojure maps are unordered data structures.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(first-value {:a "A" :b "B"})<br>=&gt;<br>"A"</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="first-value-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;first-value-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn first-value<br>  [n]<br>  (let [n (mixed/to-map n)]<br>       (-> n vals first)))</pre></div></div><div class="declaration--wrapper" id="contains-value_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">contains-value?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">x</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-value? {} "A")<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(contains-value? {:a "A"} "A")<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="contains-value_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;contains-value_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn contains-value?<br>  [n x]<br>  (let [n (mixed/to-map n)]<br>       (letfn [(f0 [%] (= x (val %)))]<br>              (some f0 n))))</pre></div></div><div class="declaration--wrapper" id="values-equal_"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">values-equal?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">a-path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">b-path</pre><pre class="text--xs color--muted">vector</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(values-equal? {:a {:b "X"} :c {:d "X"}}<br>               [:a :b] [:c :d])<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">boolean</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="values-equal_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;values-equal_-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn values-equal?<br>  [n a-path b-path]<br>  (let [n      (mixed/to-map n)<br>        a-path (mixed/to-vector a-path)<br>        b-path (mixed/to-vector b-path)]<br>       (= (get-in n a-path)<br>          (get-in n b-path))))</pre></div></div><div class="declaration--wrapper" id="-_keys"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->keys</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each key of the given 'n' map.<br>- The 'f' function takes a key and optionally the corresponding value as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;keys {:a "A" :b "B"} name)<br>=&gt;<br>{"a" "A" "b" "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_keys-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_keys-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->keys<br>  ([n f]<br>   (->keys n f {}))<br><br>  ([n f {:keys [provide-value?]}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [       k v] (if provide-value? (f k v) (f k)))<br>                (f1 [result k v] (assoc result (f0 k v) v))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="-_keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on keys of the given 'n' map that for the given 'test-f' function returns TRUE.<br>- The 'f' function takes a key and optionally the corresponding value as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;keys-by {0 "A" 1 "B"} even? dec)<br>=&gt;<br>{-1 "A" 1 "B"}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->keys-by<br>  ([n test-f f]<br>   (->keys-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-value?]}]<br>   (let [n      (mixed/to-map n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [       k v] (if provide-value? (f k v) (f k)))<br>                (f1 [       k v] (if (test-f k) (f0 k v) k))<br>                (f2 [result k v] (assoc result (f1 k v) v))]<br>               (reduce-kv f2 {} n)))))</pre></div></div><div class="declaration--wrapper" id="-__keys"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>keys</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each key of the given 'n' map (recursivelly).<br>- The 'f' function takes a key and optionally the corresponding value as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;keys {:a "A" :b "B" :c [{:d "D"}]} name)<br>=&gt;<br>{"a" "A" "b" "B" "c" [{"d" "D"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__keys-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__keys-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>keys<br>  ([n f]<br>   (->>keys n f {}))<br><br>  ([n f {:keys [provide-value?]}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [k v]    (if provide-value? (f k v) (f k)))<br>                (f1 [result] (cond (vector? result) (reduce    #(conj  %1            (f1 %2)) [] result)<br>                                   (map?    result) (reduce-kv #(assoc %1 (f0 %2 %3) (f1 %3)) {} result)<br>                                   :return  result))]<br>               (f1 n)))))</pre></div></div><div class="declaration--wrapper" id="-__keys-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>keys-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on keys of the given 'n' map (recursivelly) that for the given 'test-f' function returns TRUE.<br>- The 'f' function takes a key and optionally the corresponding value as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;keys-by {0 "A" 1 [{2 "B"}]} even? dec)<br>=&gt;<br>{-1 "A" 1 [{1 "B"}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__keys-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__keys-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>keys-by<br>  ([n test-f f]<br>   (->>keys-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-value?]}]<br>   (let [n      (mixed/to-map n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [k v]    (if provide-value? (f k v) (f k)))<br>                (f1 [k v]    (if (test-f k) (f0 k v) k))<br>                (f2 [result] (cond (vector? result) (reduce    #(conj  %1            (f2 %2)) [] result)<br>                                   (map?    result) (reduce-kv #(assoc %1 (f1 %2 %3) (f2 %3)) {} result)<br>                                   :return  result))]<br>               (f2 n)))))</pre></div></div><div class="declaration--wrapper" id="-_values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each value of the given 'n' map.<br>- The 'f' function takes a value and optionally the corresponding key as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;values {:a "A" :b "B"} keyword)<br>=&gt;<br>{:a :A :b :B}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->values<br>  ([n f]<br>   (->values n f {}))<br><br>  ([n f {:keys [provide-key?]}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [       k v] (if provide-key? (f k v) (f v)))<br>                (f1 [result k v] (assoc result k (f0 k v)))]<br>               (reduce-kv f1 {} n)))))</pre></div></div><div class="declaration--wrapper" id="-_values-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->values-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on values of the given 'n' map that for the given 'test-f' function returns TRUE.<br>- The 'f' function takes a value and optionally the corresponding key as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;values-by {:a 0 :b 1} even? inc)<br>=&gt;<br>{:a 1 :b 1}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_values-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_values-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->values-by<br>  ([n test-f f]<br>   (->values-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-key?]}]<br>   (let [n      (mixed/to-map n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [       k v] (if provide-key? (f k v) (f v)))<br>                (f1 [       k v] (if (test-f v) (f0 k v) v))<br>                (f2 [result k v] (assoc result k (f1 k v)))]<br>               (reduce-kv f2 {} n)))))</pre></div></div><div class="declaration--wrapper" id="-__values"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>values</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on each value of the given 'n' map (recursivelly).<br>- The 'f' function takes a value and optionally the corresponding key or path as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'f' function.<br>  Default: false<br> :provide-path? (boolean)(opt)<br>  If TRUE, provides the corresponding path also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;values {:a "A" :b "B" :c [:d "E" {:f "F"}]} keyword)<br>=&gt;<br>{:a :A :b :B :c [:d :e {:f :F}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__values-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__values-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>values<br>  ([n f]<br>   (->>values n f {}))<br><br>  ([n f {:keys [provide-key? provide-path?]}]<br>   (let [n (mixed/to-map n)<br>         f (mixed/to-ifn f)]<br>        (letfn [(f0 [path v] (if provide-key? (f (last path) v) (if provide-path? (f path v) (f v))))<br>                (f1 [path v] (cond (map?    v) (reduce-kv #(assoc %1 %2 (f1 (conj path %2) %3)) {} v)<br>                                   (vector? v) (reduce-kv #(conj  %1    (f1 (conj path %2) %3)) [] v)<br>                                   :return     (f0 path v)))]<br>               (f1 [] n)))))</pre></div></div><div class="declaration--wrapper" id="-__values-by"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>values-by</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function on values of the given 'n' map (recursivelly) that for the given 'test-f' function returns TRUE.<br>- The 'f' function takes a value and optionally the corresponding key or path as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">test-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'f' function.<br>  Default: false<br> :provide-path? (boolean)(opt)<br>  If TRUE, provides the corresponding path also to the given 'f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;values-by {:a 0 :b 1 :c [:d 2 {:f 3}]} integer? inc)<br>=&gt;<br>{:a 1 :b 2 :c [:d 3 {:f 4}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__values-by-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__values-by-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>values-by<br>  ([n test-f f]<br>   (->>values-by n test-f f {}))<br><br>  ([n test-f f {:keys [provide-key? provide-path?]}]<br>   (let [n      (mixed/to-map n)<br>         test-f (mixed/to-ifn test-f)<br>         f      (mixed/to-ifn f)]<br>        (letfn [(f0 [path v] (if provide-key? (f (last path) v) (if provide-path? (f path v) (f v))))<br>                (f1 [path v] (if (test-f v) (f0 path v) v))<br>                (f2 [path v] (let [v (f1 path v)] <br>                                  (cond (map?    v) (reduce-kv #(assoc %1 %2 (f2 (conj path %2) %3)) {} v)<br>                                        (vector? v) (reduce-kv #(conj  %1    (f2 (conj path %2) %3)) [] v)<br>                                        :return v)))]<br>               (f2 [] n)))))</pre></div></div><div class="declaration--wrapper" id="-_kv"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->kv</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'k-f' function on each key and the given 'v-f' function on each value of the given 'n' map.<br>- The 'k-f' function takes a key and optionally the corresponding value as parameter(s).<br>  The 'v-f' function takes a value and optionally the corresponding key as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'v-f' function.<br>  Default: false<br> :provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'k-f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;kv {:a 1 :b 2} name inc)<br>=&gt;<br>{"a" 2 "b" 3}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-_kv-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-_kv-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->kv<br>  ([n k-f v-f]<br>   (->kv n k-f v-f {}))<br><br>  ([n k-f v-f {:keys [provide-key? provide-value?]}]<br>   (let [n   (mixed/to-map n)<br>         k-f (mixed/to-ifn k-f)<br>         v-f (mixed/to-ifn v-f)]<br>        (letfn [(f0 [       k v] (if provide-value? (k-f k v) (k-f k)))<br>                (f1 [       k v] (if provide-key?   (v-f k v) (v-f v)))<br>                (f2 [result k v] (assoc result (f0 k v) (f1 k v)))]<br>               (reduce-kv f2 {} n)))))</pre></div></div><div class="declaration--wrapper" id="-__kv"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary text--bold">->>kv</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'k-f' function on each key and the given 'v-f' function on each value of the given 'n' map (recursivelly).<br>- The 'k-f' function takes a key and optionally the corresponding value as parameter(s).<br>  The 'v-f' function takes a value and optionally the corresponding key or path as parameter(s).</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">k-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">v-f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:provide-key? (boolean)(opt)<br>  If TRUE, provides the corresponding key also to the given 'v-f' function.<br>  Default: false<br> :provide-path? (boolean)(opt)<br>  If TRUE, provides the corresponding path also to the given 'v-f' function.<br>  Default: false<br> :provide-value? (boolean)(opt)<br>  If TRUE, provides the corresponding value also to the given 'k-f' function.<br>  Default: false}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(-&gt;&gt;kv {"a" "A" "b" "B" "c" ["D" "E" {"f" "F"}]} keyword keyword)<br>=&gt;<br>{:a :A :b :B :c [:D :E {:f :F}]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="-__kv-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;-__kv-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn ->>kv<br>  ([n k-f v-f]<br>   (->>kv n k-f v-f {}))<br><br>  ([n k-f v-f {:keys [provide-key? provide-path? provide-value?]}]<br>   (let [n   (mixed/to-map n)<br>         k-f (mixed/to-ifn k-f)<br>         v-f (mixed/to-ifn v-f)]<br>        (letfn [(f0 [   k v] (if provide-value? (k-f k v) (k-f k)))<br>                (f1 [path v] (if provide-key?   (v-f (last path) v) (if provide-path? (v-f path v) (v-f v))))<br>                (f2 [path v] (cond (map?    v) (reduce-kv #(assoc %1 (f0 %2 %3) (f2 (conj path %2) %3)) {} v)<br>                                   (vector? v) (reduce-kv #(conj  %1            (f2 (conj path %2) %3)) [] v)<br>                                   :return     (f1 path v)))]<br>               (f2 [] n)))))</pre></div></div></div></div><div id="top-bar"><pre class="text--bold" id="top-bar--library-name">cljc-fruits</pre><pre class="color--muted" id="top-bar--library-version">1.0.8.2</pre><a href="https://github.com/bithandshake/cljc-fruits" id="top-bar--library-uri"><pre class="color--primary">github.com/bithandshake/cljc-fruits</pre></a></div><div id="bottom-bar"><a href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>
